{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python dictionary with dot notation (A re-implementation of python-box with some issues fixed and simplified) ```python from diot import Diot movie_data = { \"movies\": { \"Spaceballs\": { \"imdb stars\": 7.1, \"rating\": \"PG\", \"length\": 96, \"director\": \"Mel Brooks\", \"stars\": [{\"name\": \"Mel Brooks\", \"imdb\": \"nm0000316\", \"role\": \"President Skroob\"}, {\"name\": \"John Candy\",\"imdb\": \"nm0001006\", \"role\": \"Barf\"}, {\"name\": \"Rick Moranis\", \"imdb\": \"nm0001548\", \"role\": \"Dark Helmet\"} ] }, \"Robin Hood: Men in Tights\": { \"imdb stars\": 6.7, \"rating\": \"PG-13\", \"length\": 104, \"director\": \"Mel Brooks\", \"stars\": [ {\"name\": \"Cary Elwes\", \"imdb\": \"nm0000144\", \"role\": \"Robin Hood\"}, {\"name\": \"Richard Lewis\", \"imdb\": \"nm0507659\", \"role\": \"Prince John\"}, {\"name\": \"Roger Rees\", \"imdb\": \"nm0715953\", \"role\": \"Sheriff of Rottingham\"}, {\"name\": \"Amy Yasbeck\", \"imdb\": \"nm0001865\", \"role\": \"Marian\"} ] } } } Box is a conversion_box by default, pass in conversion_box=False to disable that behavior Explicitly tell Diot to convert dict/list inside movie_diot = Diot(movie_data) movie_diot.movies.Robin_Hood_Men_in_Tights.imdb_stars 6.7 movie_diot.movies.Spaceballs.stars[0].name 'Mel Brooks' Different as box, you have to use Diot for new data in a list movie_diot.movies.Spaceballs.stars.append( Diot({\"name\": \"Bill Pullman\", \"imdb\": \"nm0000597\", \"role\": \"Lone Starr\"})) movie_diot.movies.Spaceballs.stars[-1].role 'Lone Starr' ``` Install shell pip install -U diot API https://pwwang.github.io/diot/api/diot/ Usage Diot Instantiated the same ways as dict ```python Diot({'data': 2, 'count': 5}) Diot(data=2, count=5) Diot({'data': 2, 'count': 1}, count=5) Diot([('data', 2), ('count', 5)]) All will create Diot([('data', 2), ('count', 5)], diot_nest = True, diot_transform = 'safe') ``` Same as python-box , Diot is a subclass of dict which overrides some base functionality to make sure everything stored in the dict can be accessed as an attribute or key value. python diot = Diot({'data': 2, 'count': 5}) diot.data == diot['data'] == getattr(diot, 'data') By default, diot uses a safe transformation to transform keys into safe names that can be accessed by diot.xxx ```python dt = Diot({\"321 Is a terrible Key!\": \"yes, really\"}) dt. 321_Is_a_terrible_Key 'yes, really' ``` Different as python-box , duplicate attributes are not allowed. ```python dt = Diot({\"!bad!key!\": \"yes, really\", \".bad.key.\": \"no doubt\"}) KeyError ``` Use different transform functions: ```python dt = Diot(oneTwo = 12, diot_transform = 'snake_case') or use alias: dt = SnakeDiot(oneTwo = 12) dt.one_two == dt['one_two'] == dt['oneTwo'] == 12 dt = Diot(one_two = 12, diot_transform = 'camel_case') or use alias: dt = CamelDiot(one_two = 12) dt.oneTwo == dt['one_two'] == dt['oneTwo'] == 12 dt = Diot(one_two = 12, diot_transform = 'upper') dt.ONE_TWO == dt['one_two'] == dt['ONETWO'] == 12 dt = Diot(ONE_TWO = 12, diot_transform = 'lower') dt.one_two == dt['ONE_TWO'] == dt['one_two'] == 12 ``` Use your own transform function: ```python import inflection dt = Diot(post = 10, diot_transform = inflection.pluralize) dt.posts == dt['posts'] == dt['post'] == 10 ``` OrderedDiot ```python diot_of_order = OrderedDiot() diot_of_order.c = 1 diot_of_order.a = 2 diot_of_order.d = 3 list(diot_of_order.keys()) == ['c', 'a', 'd'] insertion allowed for OrderedDiot od = OrderedDiot() od.insert(0, \"c\", \"d\") od.insert(None, \"x\", \"y\") od.insert_before('c', \"e\", \"f\") od.insert_after(\"a\", (\"g\", \"h\")) od2 = OrderedDiot() od2.a1 = 'b1' od2.c1 = 'd1' od.insert(-1, od2) od3 = OrderedDiot() od3.a2 = 'b2' od3.c2 = 'd2' od.insert_before('c', od3) ``` FrozenDiot python fd = FrozenDiot(a=1, b=3) fd.c = 3 # DiotFrozenError with fd.thaw(): fd.c = 3 fd.c == 3 Missing key handler ```python d = Diot(a=1, b=2, diot_missing=ValueError) d['c'] # ValueError d.c # AttributeError from ValueError d = Diot(a=1, b=2, diot_missing=ValueError(\"Custom message\")) d = Diot(a=1, b=2, diot_missing=None) d.c is None d = Diot(a=1, b=2, diot_missing=lambda key, diot: diot.a + diot.b) d.c == 3 ```","title":"Home"},{"location":"#box-is-a-conversion_box-by-default-pass-in-conversion_boxfalse-to-disable-that-behavior","text":"","title":"Box is a conversion_box by default, pass in conversion_box=False to disable that behavior"},{"location":"#explicitly-tell-diot-to-convert-dictlist-inside","text":"movie_diot = Diot(movie_data) movie_diot.movies.Robin_Hood_Men_in_Tights.imdb_stars","title":"Explicitly tell Diot to convert dict/list inside"},{"location":"#67","text":"movie_diot.movies.Spaceballs.stars[0].name","title":"6.7"},{"location":"#mel-brooks","text":"","title":"'Mel Brooks'"},{"location":"#different-as-box-you-have-to-use-diot-for-new-data-in-a-list","text":"movie_diot.movies.Spaceballs.stars.append( Diot({\"name\": \"Bill Pullman\", \"imdb\": \"nm0000597\", \"role\": \"Lone Starr\"})) movie_diot.movies.Spaceballs.stars[-1].role","title":"Different as box, you have to use Diot for new data in a list"},{"location":"#lone-starr","text":"```","title":"'Lone Starr'"},{"location":"#install","text":"shell pip install -U diot","title":"Install"},{"location":"#api","text":"https://pwwang.github.io/diot/api/diot/","title":"API"},{"location":"#usage","text":"","title":"Usage"},{"location":"#diot","text":"Instantiated the same ways as dict ```python Diot({'data': 2, 'count': 5}) Diot(data=2, count=5) Diot({'data': 2, 'count': 1}, count=5) Diot([('data', 2), ('count', 5)])","title":"Diot"},{"location":"#all-will-create","text":"","title":"All will create"},{"location":"#diotdata-2-count-5-diot_nest-true-diot_transform-safe","text":"``` Same as python-box , Diot is a subclass of dict which overrides some base functionality to make sure everything stored in the dict can be accessed as an attribute or key value. python diot = Diot({'data': 2, 'count': 5}) diot.data == diot['data'] == getattr(diot, 'data') By default, diot uses a safe transformation to transform keys into safe names that can be accessed by diot.xxx ```python dt = Diot({\"321 Is a terrible Key!\": \"yes, really\"}) dt. 321_Is_a_terrible_Key","title":"Diot([('data', 2), ('count', 5)], diot_nest = True, diot_transform = 'safe')"},{"location":"#yes-really","text":"``` Different as python-box , duplicate attributes are not allowed. ```python dt = Diot({\"!bad!key!\": \"yes, really\", \".bad.key.\": \"no doubt\"})","title":"'yes, really'"},{"location":"#keyerror","text":"``` Use different transform functions: ```python dt = Diot(oneTwo = 12, diot_transform = 'snake_case')","title":"KeyError"},{"location":"#or-use-alias","text":"","title":"or use alias:"},{"location":"#dt-snakediotonetwo-12","text":"dt.one_two == dt['one_two'] == dt['oneTwo'] == 12 dt = Diot(one_two = 12, diot_transform = 'camel_case')","title":"dt = SnakeDiot(oneTwo = 12)"},{"location":"#or-use-alias_1","text":"","title":"or use alias:"},{"location":"#dt-cameldiotone_two-12","text":"dt.oneTwo == dt['one_two'] == dt['oneTwo'] == 12 dt = Diot(one_two = 12, diot_transform = 'upper') dt.ONE_TWO == dt['one_two'] == dt['ONETWO'] == 12 dt = Diot(ONE_TWO = 12, diot_transform = 'lower') dt.one_two == dt['ONE_TWO'] == dt['one_two'] == 12 ``` Use your own transform function: ```python import inflection dt = Diot(post = 10, diot_transform = inflection.pluralize) dt.posts == dt['posts'] == dt['post'] == 10 ```","title":"dt = CamelDiot(one_two = 12)"},{"location":"#ordereddiot","text":"```python diot_of_order = OrderedDiot() diot_of_order.c = 1 diot_of_order.a = 2 diot_of_order.d = 3 list(diot_of_order.keys()) == ['c', 'a', 'd']","title":"OrderedDiot"},{"location":"#insertion-allowed-for-ordereddiot","text":"od = OrderedDiot() od.insert(0, \"c\", \"d\") od.insert(None, \"x\", \"y\") od.insert_before('c', \"e\", \"f\") od.insert_after(\"a\", (\"g\", \"h\")) od2 = OrderedDiot() od2.a1 = 'b1' od2.c1 = 'd1' od.insert(-1, od2) od3 = OrderedDiot() od3.a2 = 'b2' od3.c2 = 'd2' od.insert_before('c', od3) ```","title":"insertion allowed for OrderedDiot"},{"location":"#frozendiot","text":"python fd = FrozenDiot(a=1, b=3) fd.c = 3 # DiotFrozenError with fd.thaw(): fd.c = 3 fd.c == 3","title":"FrozenDiot"},{"location":"#missing-key-handler","text":"```python d = Diot(a=1, b=2, diot_missing=ValueError) d['c'] # ValueError d.c # AttributeError from ValueError d = Diot(a=1, b=2, diot_missing=ValueError(\"Custom message\")) d = Diot(a=1, b=2, diot_missing=None)","title":"Missing key handler"},{"location":"#dc-is-none","text":"d = Diot(a=1, b=2, diot_missing=lambda key, diot: diot.a + diot.b)","title":"d.c is None"},{"location":"#dc-3","text":"```","title":"d.c == 3"},{"location":"api/diot.diot/","text":"module diot . diot </> diot module Classes Diot \u2014 Dictionary with dot notation </> CamelDiot \u2014 With camel case conversion </> SnakeDiot \u2014 With snake case conversion </> FrozenDiot \u2014 The frozen diot </> OrderedDiot \u2014 With key order preserved </> class diot.diot . Diot ( *args , **kwargs ) </> Bases dict Dictionary with dot notation Examples ~~~python d = Diot(a=1, b=2) d.a = 2 d['a'] = 2 d.a # 2 d['a'] # 2 d.pop('a') # 2 d.pop('x', 1) # 1 d.popitem() # ('b', 2) d.update(a=3, b=4) # {'a': 3, 'b': 4} d | {'a': 1, 'b': 2} # {'a': 1, 'b': 2} (d unchanged) d |= {'a': 1, 'b': 2} # d == {'a': 1, 'b': 2} del d.a del d['b'] d.freeze() d.a = 1 # DiotFrozenError d.unfreeze() d.a = 1 # ok d.setdefault('b', 2) 'b' in d d.copy() d.deepcopy() ~~~ Parameters *args \u2014 Anything that can be sent to dict construct **kwargs \u2014 keyword argument that can be sent to dict constructSome diot configurations can also be passed, including: diot_nest: Types to nestly convert values diot_transform: The transforms for keys diot_frozen: Whether to generate a frozen diot. True: freeze the object recursively if there are Diot objects in descendants False: Don'f freeze 'shallow': Only freeze at depth = 1 diot_missing: How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Methods __contains__ ( name ) (bool) \u2014 True if the dictionary has the specified key, else False. </> __delitem__ ( name ) \u2014 Delete self[key]. </> __getitem__ ( name ) (Any) \u2014 Return self[key]. </> __ior__ ( other ) ( Diot ) \u2014 Return self|=value. </> __setitem__ ( name , value ) \u2014 Set self[key] to value. </> accessible_keys ( ) (Iterable) \u2014 Get the converted keys </> clear ( ) \u2014 Clear the object </> copy ( ) ( Diot ) \u2014 Shallow copy the object </> freeze ( frozen ) \u2014 Freeze the diot object </> from_namespace ( namespace , recursive , diot_nest , diot_transform , diot_frozen , diot_missing ) ( Diot ) \u2014 Get a Diot object from an argparse namespace </> get ( name , value ) (Any) \u2014 Get the value of a key name </> pop ( name , *value ) (Any) \u2014 Pop a key from the object and return the value. If key does notexist, return the given default value </> popitem ( ) (Tuple) \u2014 Pop last item from the object </> setdefault ( name , value ) (Any) \u2014 Set a default value to a key </> thaw ( recursive ) \u2014 A context manager for temporarily change the diot </> to_dict ( ) (Dict) \u2014 Turn the Box and sub Boxes back into a nativepython dictionary. </> to_json ( filename , encoding , errors , **json_kwargs ) (Optional) \u2014 Convert to a json string or save it to json file </> to_toml ( filename , encoding , errors ) (Optional) \u2014 Convert to a toml string or save it to toml file </> to_yaml ( filename , default_flow_style , encoding , errors , **yaml_kwargs ) (Optional) \u2014 Convert to a yaml string or save it to yaml file </> unfreeze ( recursive ) \u2014 Unfreeze the diot object </> update ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> update_recursively ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> classmethod from_namespace ( namespace , recursive=True , diot_nest=True , diot_transform='safe' , diot_frozen=False , diot_missing=<diot.diot._DiotMissingDefault object at 0x7fc343b7c9a0> ) </> Get a Diot object from an argparse namespace Example ~~~python from argparse import Namespace Diot.from_namespace(Namespace(a=1, b=2)) ~~~ Parameters namespace (Namespace) \u2014 The namespace object recursive (bool, optional) \u2014 Do it recursively? diot_nest (Union, optional) \u2014 Types to nestly convert values diot_transform (Union, optional) \u2014 The transforms for keys diot_frozen (Union, optional) \u2014 Whether to generate a frozen diot. - True: freeze the object recursively if there are Diot objects in descendants - False: Don'f freeze - shallow : Only freeze at depth = 1 diot_missing (Any, optional) \u2014 How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Returns ( Diot ) The converted diot object. method __setitem__ ( name , value ) </> Set self[key] to value. method __getitem__ ( name ) \u2192 Any </> Return self[key]. method pop ( name , *value ) </> Pop a key from the object and return the value. If key does notexist, return the given default value Parameters name (str) \u2014 The key value \u2014 The default value to return if the key does not exist Returns (Any) The value corresponding to the name or the default value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method popitem ( ) </> Pop last item from the object Returns (Tuple) A tuple of key and value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method update ( *value , **kwargs ) </> Update the object. Shortcut: |= Parameters args \u2014 args that can be sent to dict to update the object kwargs \u2014 kwargs that can be sent to dict to update the object Raises DiotFrozenError \u2014 when try to update a frozen diot method update_recursively ( *value , **kwargs ) </> Update the object. Shortcut: |= Parameters args \u2014 args that can be sent to dict to update the object kwargs \u2014 kwargs that can be sent to dict to update the object Raises DiotFrozenError \u2014 when try to update a frozen diot method __ior__ ( other ) \u2192 Diot </> Return self|=value. method __delitem__ ( name ) </> Delete self[key]. method freeze ( frozen='shallow' ) </> Freeze the diot object Parameters frozen (Union, optional) \u2014 The frozen argument indicating how to freeze:shallow: only freeze at depth=1 True: freeze recursively if there are diot objects in children False: Disable freezing method unfreeze ( recursive=False ) </> Unfreeze the diot object Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively generator thaw ( recursive=False ) </> A context manager for temporarily change the diot Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively Yields self, the reference to this diot. method setdefault ( name , value ) </> Set a default value to a key Parameters name (str) \u2014 The key name value (Any) \u2014 The default value Returns (Any) The existing value or the value passed in Raises DiotFrozenError \u2014 when try to set default to a frozen diot method accessible_keys ( ) </> Get the converted keys Returns (Iterable) The accessible (transformed) keys method get ( name , value=None ) </> Get the value of a key name Parameters name (str) \u2014 The key name value (Any, optional) \u2014 The value to return if the key does not exist Returns (Any) The corresponding value or the value passed in if the key doesnot exist method __contains__ ( name ) \u2192 bool </> True if the dictionary has the specified key, else False. method clear ( ) </> Clear the object method copy ( ) </> Shallow copy the object Returns ( Diot ) The copied object method to_dict ( ) </> Turn the Box and sub Boxes back into a nativepython dictionary. Returns (Dict) The converted python dictionary method to_json ( filename=None , encoding='utf-8' , errors='strict' , **json_kwargs ) </> Convert to a json string or save it to json file Parameters filename (Union, optional) \u2014 The filename to save the json to, if not given a jsonstring will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function **json_kwargs \u2014 Other kwargs for json.dumps Returns (Optional) The json string with filename is not given method to_yaml ( filename=None , default_flow_style=False , encoding='utf-8' , errors='strict' , **yaml_kwargs ) </> Convert to a yaml string or save it to yaml file Parameters filename (Union, optional) \u2014 The filename to save the yaml to, if not given a yamlstring will be returned default_flow_style (bool, optional) \u2014 The default flow style for yaml dumpingSee yaml.dump encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function **yaml_kwargs \u2014 Other kwargs for yaml.dump Returns (Optional) The yaml string with filename is not given method to_toml ( filename=None , encoding='utf-8' , errors='strict' ) </> Convert to a toml string or save it to toml file Parameters filename (Union, optional) \u2014 The filename to save the toml to, if not given a tomlstring will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function Returns (Optional) The toml string with filename is not given class diot.diot . CamelDiot ( *args , **kwargs ) </> Bases diot.diot.Diot dict With camel case conversion Parameters *args \u2014 Anything that can be sent to dict construct **kwargs \u2014 keyword argument that can be sent to dict constructSome diot configurations can also be passed, including: diot_nest: Types to nestly convert values diot_transform: The transforms for keys diot_frozen: Whether to generate a frozen diot. True: freeze the object recursively if there are Diot objects in descendants False: Don'f freeze 'shallow': Only freeze at depth = 1 diot_missing: How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Methods __contains__ ( name ) (bool) \u2014 True if the dictionary has the specified key, else False. </> __delitem__ ( name ) \u2014 Delete self[key]. </> __getitem__ ( name ) (Any) \u2014 Return self[key]. </> __ior__ ( other ) ( Diot ) \u2014 Return self|=value. </> __setitem__ ( name , value ) \u2014 Set self[key] to value. </> accessible_keys ( ) (Iterable) \u2014 Get the converted keys </> clear ( ) \u2014 Clear the object </> copy ( ) ( Diot ) \u2014 Shallow copy the object </> freeze ( frozen ) \u2014 Freeze the diot object </> from_namespace ( namespace , recursive , diot_nest , diot_transform , diot_frozen , diot_missing ) ( Diot ) \u2014 Get a Diot object from an argparse namespace </> get ( name , value ) (Any) \u2014 Get the value of a key name </> pop ( name , *value ) (Any) \u2014 Pop a key from the object and return the value. If key does notexist, return the given default value </> popitem ( ) (Tuple) \u2014 Pop last item from the object </> setdefault ( name , value ) (Any) \u2014 Set a default value to a key </> thaw ( recursive ) \u2014 A context manager for temporarily change the diot </> to_dict ( ) (Dict) \u2014 Turn the Box and sub Boxes back into a nativepython dictionary. </> to_json ( filename , encoding , errors , **json_kwargs ) (Optional) \u2014 Convert to a json string or save it to json file </> to_toml ( filename , encoding , errors ) (Optional) \u2014 Convert to a toml string or save it to toml file </> to_yaml ( filename , default_flow_style , encoding , errors , **yaml_kwargs ) (Optional) \u2014 Convert to a yaml string or save it to yaml file </> unfreeze ( recursive ) \u2014 Unfreeze the diot object </> update ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> update_recursively ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> classmethod from_namespace ( namespace , recursive=True , diot_nest=True , diot_transform='safe' , diot_frozen=False , diot_missing=<diot.diot._DiotMissingDefault object at 0x7fc343b7c9a0> ) </> Get a Diot object from an argparse namespace Example ~~~python from argparse import Namespace Diot.from_namespace(Namespace(a=1, b=2)) ~~~ Parameters namespace (Namespace) \u2014 The namespace object recursive (bool, optional) \u2014 Do it recursively? diot_nest (Union, optional) \u2014 Types to nestly convert values diot_transform (Union, optional) \u2014 The transforms for keys diot_frozen (Union, optional) \u2014 Whether to generate a frozen diot. - True: freeze the object recursively if there are Diot objects in descendants - False: Don'f freeze - shallow : Only freeze at depth = 1 diot_missing (Any, optional) \u2014 How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Returns ( Diot ) The converted diot object. method __setitem__ ( name , value ) </> Set self[key] to value. method __getitem__ ( name ) \u2192 Any </> Return self[key]. method pop ( name , *value ) </> Pop a key from the object and return the value. If key does notexist, return the given default value Parameters name (str) \u2014 The key Returns (Any) The value corresponding to the name or the default value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method popitem ( ) </> Pop last item from the object Returns (Tuple) A tuple of key and value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method update ( *value , **kwargs ) </> Update the object. Shortcut: |= Raises DiotFrozenError \u2014 when try to update a frozen diot method update_recursively ( *value , **kwargs ) </> Update the object. Shortcut: |= Raises DiotFrozenError \u2014 when try to update a frozen diot method __ior__ ( other ) \u2192 Diot </> Return self|=value. method __delitem__ ( name ) </> Delete self[key]. method freeze ( frozen='shallow' ) </> Freeze the diot object Parameters frozen (Union, optional) \u2014 The frozen argument indicating how to freeze:shallow: only freeze at depth=1 True: freeze recursively if there are diot objects in children False: Disable freezing method unfreeze ( recursive=False ) </> Unfreeze the diot object Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively generator thaw ( recursive=False ) </> A context manager for temporarily change the diot Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively Yields self, the reference to this diot. method setdefault ( name , value ) </> Set a default value to a key Parameters name (str) \u2014 The key name value (Any) \u2014 The default value Returns (Any) The existing value or the value passed in Raises DiotFrozenError \u2014 when try to set default to a frozen diot method accessible_keys ( ) </> Get the converted keys Returns (Iterable) The accessible (transformed) keys method get ( name , value=None ) </> Get the value of a key name Parameters name (str) \u2014 The key name value (Any, optional) \u2014 The value to return if the key does not exist Returns (Any) The corresponding value or the value passed in if the key doesnot exist method __contains__ ( name ) \u2192 bool </> True if the dictionary has the specified key, else False. method clear ( ) </> Clear the object method copy ( ) </> Shallow copy the object Returns ( Diot ) The copied object method to_dict ( ) </> Turn the Box and sub Boxes back into a nativepython dictionary. Returns (Dict) The converted python dictionary method to_json ( filename=None , encoding='utf-8' , errors='strict' , **json_kwargs ) </> Convert to a json string or save it to json file Parameters filename (Union, optional) \u2014 The filename to save the json to, if not given a jsonstring will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function **json_kwargs \u2014 Other kwargs for json.dumps Returns (Optional) The json string with filename is not given method to_yaml ( filename=None , default_flow_style=False , encoding='utf-8' , errors='strict' , **yaml_kwargs ) </> Convert to a yaml string or save it to yaml file Parameters filename (Union, optional) \u2014 The filename to save the yaml to, if not given a yamlstring will be returned default_flow_style (bool, optional) \u2014 The default flow style for yaml dumpingSee yaml.dump encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function **yaml_kwargs \u2014 Other kwargs for yaml.dump Returns (Optional) The yaml string with filename is not given method to_toml ( filename=None , encoding='utf-8' , errors='strict' ) </> Convert to a toml string or save it to toml file Parameters filename (Union, optional) \u2014 The filename to save the toml to, if not given a tomlstring will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function Returns (Optional) The toml string with filename is not given class diot.diot . SnakeDiot ( *args , **kwargs ) </> Bases diot.diot.Diot dict With snake case conversion Parameters *args \u2014 Anything that can be sent to dict construct **kwargs \u2014 keyword argument that can be sent to dict constructSome diot configurations can also be passed, including: diot_nest: Types to nestly convert values diot_transform: The transforms for keys diot_frozen: Whether to generate a frozen diot. True: freeze the object recursively if there are Diot objects in descendants False: Don'f freeze 'shallow': Only freeze at depth = 1 diot_missing: How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Methods __contains__ ( name ) (bool) \u2014 True if the dictionary has the specified key, else False. </> __delitem__ ( name ) \u2014 Delete self[key]. </> __getitem__ ( name ) (Any) \u2014 Return self[key]. </> __ior__ ( other ) ( Diot ) \u2014 Return self|=value. </> __setitem__ ( name , value ) \u2014 Set self[key] to value. </> accessible_keys ( ) (Iterable) \u2014 Get the converted keys </> clear ( ) \u2014 Clear the object </> copy ( ) ( Diot ) \u2014 Shallow copy the object </> freeze ( frozen ) \u2014 Freeze the diot object </> from_namespace ( namespace , recursive , diot_nest , diot_transform , diot_frozen , diot_missing ) ( Diot ) \u2014 Get a Diot object from an argparse namespace </> get ( name , value ) (Any) \u2014 Get the value of a key name </> pop ( name , *value ) (Any) \u2014 Pop a key from the object and return the value. If key does notexist, return the given default value </> popitem ( ) (Tuple) \u2014 Pop last item from the object </> setdefault ( name , value ) (Any) \u2014 Set a default value to a key </> thaw ( recursive ) \u2014 A context manager for temporarily change the diot </> to_dict ( ) (Dict) \u2014 Turn the Box and sub Boxes back into a nativepython dictionary. </> to_json ( filename , encoding , errors , **json_kwargs ) (Optional) \u2014 Convert to a json string or save it to json file </> to_toml ( filename , encoding , errors ) (Optional) \u2014 Convert to a toml string or save it to toml file </> to_yaml ( filename , default_flow_style , encoding , errors , **yaml_kwargs ) (Optional) \u2014 Convert to a yaml string or save it to yaml file </> unfreeze ( recursive ) \u2014 Unfreeze the diot object </> update ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> update_recursively ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> classmethod from_namespace ( namespace , recursive=True , diot_nest=True , diot_transform='safe' , diot_frozen=False , diot_missing=<diot.diot._DiotMissingDefault object at 0x7fc343b7c9a0> ) </> Get a Diot object from an argparse namespace Example ~~~python from argparse import Namespace Diot.from_namespace(Namespace(a=1, b=2)) ~~~ Parameters namespace (Namespace) \u2014 The namespace object recursive (bool, optional) \u2014 Do it recursively? diot_nest (Union, optional) \u2014 Types to nestly convert values diot_transform (Union, optional) \u2014 The transforms for keys diot_frozen (Union, optional) \u2014 Whether to generate a frozen diot. - True: freeze the object recursively if there are Diot objects in descendants - False: Don'f freeze - shallow : Only freeze at depth = 1 diot_missing (Any, optional) \u2014 How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Returns ( Diot ) The converted diot object. method __setitem__ ( name , value ) </> Set self[key] to value. method __getitem__ ( name ) \u2192 Any </> Return self[key]. method pop ( name , *value ) </> Pop a key from the object and return the value. If key does notexist, return the given default value Parameters name (str) \u2014 The key Returns (Any) The value corresponding to the name or the default value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method popitem ( ) </> Pop last item from the object Returns (Tuple) A tuple of key and value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method update ( *value , **kwargs ) </> Update the object. Shortcut: |= Raises DiotFrozenError \u2014 when try to update a frozen diot method update_recursively ( *value , **kwargs ) </> Update the object. Shortcut: |= Raises DiotFrozenError \u2014 when try to update a frozen diot method __ior__ ( other ) \u2192 Diot </> Return self|=value. method __delitem__ ( name ) </> Delete self[key]. method freeze ( frozen='shallow' ) </> Freeze the diot object Parameters frozen (Union, optional) \u2014 The frozen argument indicating how to freeze:shallow: only freeze at depth=1 True: freeze recursively if there are diot objects in children False: Disable freezing method unfreeze ( recursive=False ) </> Unfreeze the diot object Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively generator thaw ( recursive=False ) </> A context manager for temporarily change the diot Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively Yields self, the reference to this diot. method setdefault ( name , value ) </> Set a default value to a key Parameters name (str) \u2014 The key name value (Any) \u2014 The default value Returns (Any) The existing value or the value passed in Raises DiotFrozenError \u2014 when try to set default to a frozen diot method accessible_keys ( ) </> Get the converted keys Returns (Iterable) The accessible (transformed) keys method get ( name , value=None ) </> Get the value of a key name Parameters name (str) \u2014 The key name value (Any, optional) \u2014 The value to return if the key does not exist Returns (Any) The corresponding value or the value passed in if the key doesnot exist method __contains__ ( name ) \u2192 bool </> True if the dictionary has the specified key, else False. method clear ( ) </> Clear the object method copy ( ) </> Shallow copy the object Returns ( Diot ) The copied object method to_dict ( ) </> Turn the Box and sub Boxes back into a nativepython dictionary. Returns (Dict) The converted python dictionary method to_json ( filename=None , encoding='utf-8' , errors='strict' , **json_kwargs ) </> Convert to a json string or save it to json file Parameters filename (Union, optional) \u2014 The filename to save the json to, if not given a jsonstring will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function **json_kwargs \u2014 Other kwargs for json.dumps Returns (Optional) The json string with filename is not given method to_yaml ( filename=None , default_flow_style=False , encoding='utf-8' , errors='strict' , **yaml_kwargs ) </> Convert to a yaml string or save it to yaml file Parameters filename (Union, optional) \u2014 The filename to save the yaml to, if not given a yamlstring will be returned default_flow_style (bool, optional) \u2014 The default flow style for yaml dumpingSee yaml.dump encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function **yaml_kwargs \u2014 Other kwargs for yaml.dump Returns (Optional) The yaml string with filename is not given method to_toml ( filename=None , encoding='utf-8' , errors='strict' ) </> Convert to a toml string or save it to toml file Parameters filename (Union, optional) \u2014 The filename to save the toml to, if not given a tomlstring will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function Returns (Optional) The toml string with filename is not given class diot.diot . FrozenDiot ( *args , **kwargs ) </> Bases diot.diot.Diot dict The frozen diot Parameters *args \u2014 Anything that can be sent to dict construct **kwargs \u2014 keyword argument that can be sent to dict constructSome diot configurations can also be passed, including: diot_nest: Types to nestly convert values diot_transform: The transforms for keys diot_frozen: Whether to generate a frozen diot. True: freeze the object recursively if there are Diot objects in descendants False: Don'f freeze 'shallow': Only freeze at depth = 1 diot_missing: How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Methods __contains__ ( name ) (bool) \u2014 True if the dictionary has the specified key, else False. </> __delitem__ ( name ) \u2014 Delete self[key]. </> __getitem__ ( name ) (Any) \u2014 Return self[key]. </> __ior__ ( other ) ( Diot ) \u2014 Return self|=value. </> __setitem__ ( name , value ) \u2014 Set self[key] to value. </> accessible_keys ( ) (Iterable) \u2014 Get the converted keys </> clear ( ) \u2014 Clear the object </> copy ( ) ( Diot ) \u2014 Shallow copy the object </> freeze ( frozen ) \u2014 Freeze the diot object </> from_namespace ( namespace , recursive , diot_nest , diot_transform , diot_frozen , diot_missing ) ( Diot ) \u2014 Get a Diot object from an argparse namespace </> get ( name , value ) (Any) \u2014 Get the value of a key name </> pop ( name , *value ) (Any) \u2014 Pop a key from the object and return the value. If key does notexist, return the given default value </> popitem ( ) (Tuple) \u2014 Pop last item from the object </> setdefault ( name , value ) (Any) \u2014 Set a default value to a key </> thaw ( recursive ) \u2014 A context manager for temporarily change the diot </> to_dict ( ) (Dict) \u2014 Turn the Box and sub Boxes back into a nativepython dictionary. </> to_json ( filename , encoding , errors , **json_kwargs ) (Optional) \u2014 Convert to a json string or save it to json file </> to_toml ( filename , encoding , errors ) (Optional) \u2014 Convert to a toml string or save it to toml file </> to_yaml ( filename , default_flow_style , encoding , errors , **yaml_kwargs ) (Optional) \u2014 Convert to a yaml string or save it to yaml file </> unfreeze ( recursive ) \u2014 Unfreeze the diot object </> update ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> update_recursively ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> classmethod from_namespace ( namespace , recursive=True , diot_nest=True , diot_transform='safe' , diot_frozen=False , diot_missing=<diot.diot._DiotMissingDefault object at 0x7fc343b7c9a0> ) </> Get a Diot object from an argparse namespace Example ~~~python from argparse import Namespace Diot.from_namespace(Namespace(a=1, b=2)) ~~~ Parameters namespace (Namespace) \u2014 The namespace object recursive (bool, optional) \u2014 Do it recursively? diot_nest (Union, optional) \u2014 Types to nestly convert values diot_transform (Union, optional) \u2014 The transforms for keys diot_frozen (Union, optional) \u2014 Whether to generate a frozen diot. - True: freeze the object recursively if there are Diot objects in descendants - False: Don'f freeze - shallow : Only freeze at depth = 1 diot_missing (Any, optional) \u2014 How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Returns ( Diot ) The converted diot object. method __setitem__ ( name , value ) </> Set self[key] to value. method __getitem__ ( name ) \u2192 Any </> Return self[key]. method pop ( name , *value ) </> Pop a key from the object and return the value. If key does notexist, return the given default value Parameters name (str) \u2014 The key Returns (Any) The value corresponding to the name or the default value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method popitem ( ) </> Pop last item from the object Returns (Tuple) A tuple of key and value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method update ( *value , **kwargs ) </> Update the object. Shortcut: |= Raises DiotFrozenError \u2014 when try to update a frozen diot method update_recursively ( *value , **kwargs ) </> Update the object. Shortcut: |= Raises DiotFrozenError \u2014 when try to update a frozen diot method __ior__ ( other ) \u2192 Diot </> Return self|=value. method __delitem__ ( name ) </> Delete self[key]. method freeze ( frozen='shallow' ) </> Freeze the diot object Parameters frozen (Union, optional) \u2014 The frozen argument indicating how to freeze:shallow: only freeze at depth=1 True: freeze recursively if there are diot objects in children False: Disable freezing method unfreeze ( recursive=False ) </> Unfreeze the diot object Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively generator thaw ( recursive=False ) </> A context manager for temporarily change the diot Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively Yields self, the reference to this diot. method setdefault ( name , value ) </> Set a default value to a key Parameters name (str) \u2014 The key name value (Any) \u2014 The default value Returns (Any) The existing value or the value passed in Raises DiotFrozenError \u2014 when try to set default to a frozen diot method accessible_keys ( ) </> Get the converted keys Returns (Iterable) The accessible (transformed) keys method get ( name , value=None ) </> Get the value of a key name Parameters name (str) \u2014 The key name value (Any, optional) \u2014 The value to return if the key does not exist Returns (Any) The corresponding value or the value passed in if the key doesnot exist method __contains__ ( name ) \u2192 bool </> True if the dictionary has the specified key, else False. method clear ( ) </> Clear the object method copy ( ) </> Shallow copy the object Returns ( Diot ) The copied object method to_dict ( ) </> Turn the Box and sub Boxes back into a nativepython dictionary. Returns (Dict) The converted python dictionary method to_json ( filename=None , encoding='utf-8' , errors='strict' , **json_kwargs ) </> Convert to a json string or save it to json file Parameters filename (Union, optional) \u2014 The filename to save the json to, if not given a jsonstring will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function **json_kwargs \u2014 Other kwargs for json.dumps Returns (Optional) The json string with filename is not given method to_yaml ( filename=None , default_flow_style=False , encoding='utf-8' , errors='strict' , **yaml_kwargs ) </> Convert to a yaml string or save it to yaml file Parameters filename (Union, optional) \u2014 The filename to save the yaml to, if not given a yamlstring will be returned default_flow_style (bool, optional) \u2014 The default flow style for yaml dumpingSee yaml.dump encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function **yaml_kwargs \u2014 Other kwargs for yaml.dump Returns (Optional) The yaml string with filename is not given method to_toml ( filename=None , encoding='utf-8' , errors='strict' ) </> Convert to a toml string or save it to toml file Parameters filename (Union, optional) \u2014 The filename to save the toml to, if not given a tomlstring will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function Returns (Optional) The toml string with filename is not given class diot.diot . OrderedDiot ( *args , **kwargs ) </> Bases diot.diot.Diot dict With key order preserved Parameters *args \u2014 Anything that can be sent to dict construct **kwargs \u2014 keyword argument that can be sent to dict constructSome diot configurations can also be passed, including: diot_nest: Types to nestly convert values diot_transform: The transforms for keys diot_frozen: Whether to generate a frozen diot. True: freeze the object recursively if there are Diot objects in descendants False: Don'f freeze 'shallow': Only freeze at depth = 1 diot_missing: How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Methods __contains__ ( name ) (bool) \u2014 True if the dictionary has the specified key, else False. </> __delitem__ ( name ) \u2014 Delete self[key]. </> __getitem__ ( name ) (Any) \u2014 Return self[key]. </> __ior__ ( other ) ( Diot ) \u2014 Return self|=value. </> __iter__ ( ) (Iterable) \u2014 Implement iter(self). </> __reversed__ ( ) (Iterable) \u2014 Return a reverse iterator over the dict keys. </> __setitem__ ( name , value ) \u2014 Set self[key] to value. </> accessible_keys ( ) (Iterable) \u2014 Get the converted keys </> clear ( ) \u2014 Clear the object </> copy ( ) ( Diot ) \u2014 Shallow copy the object </> copy ( ) ( OrderedDiot ) \u2014 Shallow copy the object </> freeze ( frozen ) \u2014 Freeze the diot object </> from_namespace ( namespace , recursive , diot_nest , diot_transform , diot_frozen , diot_missing ) ( Diot ) \u2014 Get a Diot object from an argparse namespace </> get ( name , value ) (Any) \u2014 Get the value of a key name </> insert ( position , name , value ) \u2014 Insert an item to certain position </> insert_after ( existing_key , name , value ) \u2014 Insert items after the specified key </> insert_before ( existing_key , name , value ) \u2014 Insert items before the specified key </> items ( ) (Iterator) \u2014 Get the items in the order of the keys </> keys ( ) (Iterable) \u2014 Get the keys in the order they are added </> pop ( name , *value ) (Any) \u2014 Pop a key from the object and return the value. If key does notexist, return the given default value </> popitem ( ) (Tuple) \u2014 Pop last item from the object </> setdefault ( name , value ) (Any) \u2014 Set a default value to a key </> thaw ( recursive ) \u2014 A context manager for temporarily change the diot </> to_dict ( ) (Dict) \u2014 Turn the Box and sub Boxes back into a nativepython dictionary. </> to_json ( filename , encoding , errors , **json_kwargs ) (Optional) \u2014 Convert to a json string or save it to json file </> to_toml ( filename , encoding , errors ) (Optional) \u2014 Convert to a toml string or save it to toml file </> to_yaml ( filename , default_flow_style , encoding , errors , **yaml_kwargs ) (Optional) \u2014 Convert to a yaml string or save it to yaml file </> unfreeze ( recursive ) \u2014 Unfreeze the diot object </> update ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> update_recursively ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> values ( ) (Iterable) \u2014 Get the values in the order they are added </> classmethod from_namespace ( namespace , recursive=True , diot_nest=True , diot_transform='safe' , diot_frozen=False , diot_missing=<diot.diot._DiotMissingDefault object at 0x7fc343b7c9a0> ) </> Get a Diot object from an argparse namespace Example ~~~python from argparse import Namespace Diot.from_namespace(Namespace(a=1, b=2)) ~~~ Parameters namespace (Namespace) \u2014 The namespace object recursive (bool, optional) \u2014 Do it recursively? diot_nest (Union, optional) \u2014 Types to nestly convert values diot_transform (Union, optional) \u2014 The transforms for keys diot_frozen (Union, optional) \u2014 Whether to generate a frozen diot. - True: freeze the object recursively if there are Diot objects in descendants - False: Don'f freeze - shallow : Only freeze at depth = 1 diot_missing (Any, optional) \u2014 How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Returns ( Diot ) The converted diot object. method __getitem__ ( name ) \u2192 Any </> Return self[key]. method popitem ( ) </> Pop last item from the object Returns (Tuple) A tuple of key and value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method update ( *value , **kwargs ) </> Update the object. Shortcut: |= Raises DiotFrozenError \u2014 when try to update a frozen diot method update_recursively ( *value , **kwargs ) </> Update the object. Shortcut: |= Raises DiotFrozenError \u2014 when try to update a frozen diot method __ior__ ( other ) \u2192 Diot </> Return self|=value. method freeze ( frozen='shallow' ) </> Freeze the diot object Parameters frozen (Union, optional) \u2014 The frozen argument indicating how to freeze:shallow: only freeze at depth=1 True: freeze recursively if there are diot objects in children False: Disable freezing method unfreeze ( recursive=False ) </> Unfreeze the diot object Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively generator thaw ( recursive=False ) </> A context manager for temporarily change the diot Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively Yields self, the reference to this diot. method setdefault ( name , value ) </> Set a default value to a key Parameters name (str) \u2014 The key name value (Any) \u2014 The default value Returns (Any) The existing value or the value passed in Raises DiotFrozenError \u2014 when try to set default to a frozen diot method accessible_keys ( ) </> Get the converted keys Returns (Iterable) The accessible (transformed) keys method get ( name , value=None ) </> Get the value of a key name Parameters name (str) \u2014 The key name value (Any, optional) \u2014 The value to return if the key does not exist Returns (Any) The corresponding value or the value passed in if the key doesnot exist method __contains__ ( name ) \u2192 bool </> True if the dictionary has the specified key, else False. method copy ( ) </> Shallow copy the object Returns ( Diot ) The copied object method to_dict ( ) </> Turn the Box and sub Boxes back into a nativepython dictionary. Returns (Dict) The converted python dictionary method to_json ( filename=None , encoding='utf-8' , errors='strict' , **json_kwargs ) </> Convert to a json string or save it to json file Parameters filename (Union, optional) \u2014 The filename to save the json to, if not given a jsonstring will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function **json_kwargs \u2014 Other kwargs for json.dumps Returns (Optional) The json string with filename is not given method to_yaml ( filename=None , default_flow_style=False , encoding='utf-8' , errors='strict' , **yaml_kwargs ) </> Convert to a yaml string or save it to yaml file Parameters filename (Union, optional) \u2014 The filename to save the yaml to, if not given a yamlstring will be returned default_flow_style (bool, optional) \u2014 The default flow style for yaml dumpingSee yaml.dump encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function **yaml_kwargs \u2014 Other kwargs for yaml.dump Returns (Optional) The yaml string with filename is not given method to_toml ( filename=None , encoding='utf-8' , errors='strict' ) </> Convert to a toml string or save it to toml file Parameters filename (Union, optional) \u2014 The filename to save the toml to, if not given a tomlstring will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function Returns (Optional) The toml string with filename is not given method __setitem__ ( name , value ) </> Set self[key] to value. method items ( ) </> Get the items in the order of the keys Returns (Iterator) The items (key-value) of the object method insert ( position , name , value=None ) </> Insert an item to certain position Parameters position (int) \u2014 The position where the name-value pair to be inserted name (Union) \u2014 The key name to be insertedIt could also be a tuple of key-value pair. In such a case, value is ignored. It could be an ordered dictionary as well value (Any, optional) \u2014 The value to be inserted Raises ValueError \u2014 when try to pass a value if name is key-value pair ora dictonary. ValueError \u2014 when name is a tuple but not with 2 elements method insert_before ( existing_key , name , value=None ) </> Insert items before the specified key Parameters existing_key (str) \u2014 The key where the new elements to be inserted before name (str) \u2014 The key name to be inserted value (Any, optional) \u2014 The value to be insertedSame as name and value arguments for insert Raises KeyError \u2014 when existing key does not exist KeyError \u2014 when name is an existing key method insert_after ( existing_key , name , value=None ) </> Insert items after the specified key Parameters existing_key (str) \u2014 The key where the new elements to be inserted after name (str) \u2014 The key name to be inserted value (Any, optional) \u2014 The value to be insertedSame as name and value arguments for insert Raises KeyError \u2014 when existing key does not exist KeyError \u2014 when name is an existing key method keys ( ) </> Get the keys in the order they are added Returns (Iterable) The keys (untransformed) method __iter__ ( ) \u2192 Iterable </> Implement iter(self). method values ( ) </> Get the values in the order they are added Returns (Iterable) The values of the object method __delitem__ ( name ) </> Delete self[key]. method pop ( name , *value ) </> Pop a key from the object and return the value. If key does notexist, return the given default value Parameters name (str) \u2014 The key Returns (Any) The value corresponding to the name or the default value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method __reversed__ ( ) \u2192 Iterable </> Return a reverse iterator over the dict keys. method clear ( ) </> Clear the object method copy ( ) </> Shallow copy the object Returns ( OrderedDiot ) The copied object","title":"diot.diot"},{"location":"api/diot.diot/#diotdiot","text":"</> diot module Classes Diot \u2014 Dictionary with dot notation </> CamelDiot \u2014 With camel case conversion </> SnakeDiot \u2014 With snake case conversion </> FrozenDiot \u2014 The frozen diot </> OrderedDiot \u2014 With key order preserved </> class","title":"diot.diot"},{"location":"api/diot.diot/#diotdiotdiot","text":"</> Bases dict Dictionary with dot notation Examples ~~~python d = Diot(a=1, b=2) d.a = 2 d['a'] = 2 d.a # 2 d['a'] # 2 d.pop('a') # 2 d.pop('x', 1) # 1 d.popitem() # ('b', 2) d.update(a=3, b=4) # {'a': 3, 'b': 4} d | {'a': 1, 'b': 2} # {'a': 1, 'b': 2} (d unchanged) d |= {'a': 1, 'b': 2} # d == {'a': 1, 'b': 2} del d.a del d['b'] d.freeze() d.a = 1 # DiotFrozenError d.unfreeze() d.a = 1 # ok d.setdefault('b', 2) 'b' in d d.copy() d.deepcopy() ~~~ Parameters *args \u2014 Anything that can be sent to dict construct **kwargs \u2014 keyword argument that can be sent to dict constructSome diot configurations can also be passed, including: diot_nest: Types to nestly convert values diot_transform: The transforms for keys diot_frozen: Whether to generate a frozen diot. True: freeze the object recursively if there are Diot objects in descendants False: Don'f freeze 'shallow': Only freeze at depth = 1 diot_missing: How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Methods __contains__ ( name ) (bool) \u2014 True if the dictionary has the specified key, else False. </> __delitem__ ( name ) \u2014 Delete self[key]. </> __getitem__ ( name ) (Any) \u2014 Return self[key]. </> __ior__ ( other ) ( Diot ) \u2014 Return self|=value. </> __setitem__ ( name , value ) \u2014 Set self[key] to value. </> accessible_keys ( ) (Iterable) \u2014 Get the converted keys </> clear ( ) \u2014 Clear the object </> copy ( ) ( Diot ) \u2014 Shallow copy the object </> freeze ( frozen ) \u2014 Freeze the diot object </> from_namespace ( namespace , recursive , diot_nest , diot_transform , diot_frozen , diot_missing ) ( Diot ) \u2014 Get a Diot object from an argparse namespace </> get ( name , value ) (Any) \u2014 Get the value of a key name </> pop ( name , *value ) (Any) \u2014 Pop a key from the object and return the value. If key does notexist, return the given default value </> popitem ( ) (Tuple) \u2014 Pop last item from the object </> setdefault ( name , value ) (Any) \u2014 Set a default value to a key </> thaw ( recursive ) \u2014 A context manager for temporarily change the diot </> to_dict ( ) (Dict) \u2014 Turn the Box and sub Boxes back into a nativepython dictionary. </> to_json ( filename , encoding , errors , **json_kwargs ) (Optional) \u2014 Convert to a json string or save it to json file </> to_toml ( filename , encoding , errors ) (Optional) \u2014 Convert to a toml string or save it to toml file </> to_yaml ( filename , default_flow_style , encoding , errors , **yaml_kwargs ) (Optional) \u2014 Convert to a yaml string or save it to yaml file </> unfreeze ( recursive ) \u2014 Unfreeze the diot object </> update ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> update_recursively ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> classmethod","title":"diot.diot.Diot"},{"location":"api/diot.diot/#diotdiotdiotfrom_namespace","text":"</> Get a Diot object from an argparse namespace Example ~~~python from argparse import Namespace Diot.from_namespace(Namespace(a=1, b=2)) ~~~ Parameters namespace (Namespace) \u2014 The namespace object recursive (bool, optional) \u2014 Do it recursively? diot_nest (Union, optional) \u2014 Types to nestly convert values diot_transform (Union, optional) \u2014 The transforms for keys diot_frozen (Union, optional) \u2014 Whether to generate a frozen diot. - True: freeze the object recursively if there are Diot objects in descendants - False: Don'f freeze - shallow : Only freeze at depth = 1 diot_missing (Any, optional) \u2014 How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Returns ( Diot ) The converted diot object. method","title":"diot.diot.Diot.from_namespace"},{"location":"api/diot.diot/#diotdiotdiotsetitem","text":"</> Set self[key] to value. method","title":"diot.diot.Diot.setitem"},{"location":"api/diot.diot/#diotdiotdiotgetitem","text":"</> Return self[key]. method","title":"diot.diot.Diot.getitem"},{"location":"api/diot.diot/#diotdiotdiotpop","text":"</> Pop a key from the object and return the value. If key does notexist, return the given default value Parameters name (str) \u2014 The key value \u2014 The default value to return if the key does not exist Returns (Any) The value corresponding to the name or the default value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method","title":"diot.diot.Diot.pop"},{"location":"api/diot.diot/#diotdiotdiotpopitem","text":"</> Pop last item from the object Returns (Tuple) A tuple of key and value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method","title":"diot.diot.Diot.popitem"},{"location":"api/diot.diot/#diotdiotdiotupdate","text":"</> Update the object. Shortcut: |= Parameters args \u2014 args that can be sent to dict to update the object kwargs \u2014 kwargs that can be sent to dict to update the object Raises DiotFrozenError \u2014 when try to update a frozen diot method","title":"diot.diot.Diot.update"},{"location":"api/diot.diot/#diotdiotdiotupdate_recursively","text":"</> Update the object. Shortcut: |= Parameters args \u2014 args that can be sent to dict to update the object kwargs \u2014 kwargs that can be sent to dict to update the object Raises DiotFrozenError \u2014 when try to update a frozen diot method","title":"diot.diot.Diot.update_recursively"},{"location":"api/diot.diot/#diotdiotdiotior","text":"</> Return self|=value. method","title":"diot.diot.Diot.ior"},{"location":"api/diot.diot/#diotdiotdiotdelitem","text":"</> Delete self[key]. method","title":"diot.diot.Diot.delitem"},{"location":"api/diot.diot/#diotdiotdiotfreeze","text":"</> Freeze the diot object Parameters frozen (Union, optional) \u2014 The frozen argument indicating how to freeze:shallow: only freeze at depth=1 True: freeze recursively if there are diot objects in children False: Disable freezing method","title":"diot.diot.Diot.freeze"},{"location":"api/diot.diot/#diotdiotdiotunfreeze","text":"</> Unfreeze the diot object Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively generator","title":"diot.diot.Diot.unfreeze"},{"location":"api/diot.diot/#diotdiotdiotthaw","text":"</> A context manager for temporarily change the diot Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively Yields self, the reference to this diot. method","title":"diot.diot.Diot.thaw"},{"location":"api/diot.diot/#diotdiotdiotsetdefault","text":"</> Set a default value to a key Parameters name (str) \u2014 The key name value (Any) \u2014 The default value Returns (Any) The existing value or the value passed in Raises DiotFrozenError \u2014 when try to set default to a frozen diot method","title":"diot.diot.Diot.setdefault"},{"location":"api/diot.diot/#diotdiotdiotaccessible_keys","text":"</> Get the converted keys Returns (Iterable) The accessible (transformed) keys method","title":"diot.diot.Diot.accessible_keys"},{"location":"api/diot.diot/#diotdiotdiotget","text":"</> Get the value of a key name Parameters name (str) \u2014 The key name value (Any, optional) \u2014 The value to return if the key does not exist Returns (Any) The corresponding value or the value passed in if the key doesnot exist method","title":"diot.diot.Diot.get"},{"location":"api/diot.diot/#diotdiotdiotcontains","text":"</> True if the dictionary has the specified key, else False. method","title":"diot.diot.Diot.contains"},{"location":"api/diot.diot/#diotdiotdiotclear","text":"</> Clear the object method","title":"diot.diot.Diot.clear"},{"location":"api/diot.diot/#diotdiotdiotcopy","text":"</> Shallow copy the object Returns ( Diot ) The copied object method","title":"diot.diot.Diot.copy"},{"location":"api/diot.diot/#diotdiotdiotto_dict","text":"</> Turn the Box and sub Boxes back into a nativepython dictionary. Returns (Dict) The converted python dictionary method","title":"diot.diot.Diot.to_dict"},{"location":"api/diot.diot/#diotdiotdiotto_json","text":"</> Convert to a json string or save it to json file Parameters filename (Union, optional) \u2014 The filename to save the json to, if not given a jsonstring will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function **json_kwargs \u2014 Other kwargs for json.dumps Returns (Optional) The json string with filename is not given method","title":"diot.diot.Diot.to_json"},{"location":"api/diot.diot/#diotdiotdiotto_yaml","text":"</> Convert to a yaml string or save it to yaml file Parameters filename (Union, optional) \u2014 The filename to save the yaml to, if not given a yamlstring will be returned default_flow_style (bool, optional) \u2014 The default flow style for yaml dumpingSee yaml.dump encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function **yaml_kwargs \u2014 Other kwargs for yaml.dump Returns (Optional) The yaml string with filename is not given method","title":"diot.diot.Diot.to_yaml"},{"location":"api/diot.diot/#diotdiotdiotto_toml","text":"</> Convert to a toml string or save it to toml file Parameters filename (Union, optional) \u2014 The filename to save the toml to, if not given a tomlstring will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function Returns (Optional) The toml string with filename is not given class","title":"diot.diot.Diot.to_toml"},{"location":"api/diot.diot/#diotdiotcameldiot","text":"</> Bases diot.diot.Diot dict With camel case conversion Parameters *args \u2014 Anything that can be sent to dict construct **kwargs \u2014 keyword argument that can be sent to dict constructSome diot configurations can also be passed, including: diot_nest: Types to nestly convert values diot_transform: The transforms for keys diot_frozen: Whether to generate a frozen diot. True: freeze the object recursively if there are Diot objects in descendants False: Don'f freeze 'shallow': Only freeze at depth = 1 diot_missing: How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Methods __contains__ ( name ) (bool) \u2014 True if the dictionary has the specified key, else False. </> __delitem__ ( name ) \u2014 Delete self[key]. </> __getitem__ ( name ) (Any) \u2014 Return self[key]. </> __ior__ ( other ) ( Diot ) \u2014 Return self|=value. </> __setitem__ ( name , value ) \u2014 Set self[key] to value. </> accessible_keys ( ) (Iterable) \u2014 Get the converted keys </> clear ( ) \u2014 Clear the object </> copy ( ) ( Diot ) \u2014 Shallow copy the object </> freeze ( frozen ) \u2014 Freeze the diot object </> from_namespace ( namespace , recursive , diot_nest , diot_transform , diot_frozen , diot_missing ) ( Diot ) \u2014 Get a Diot object from an argparse namespace </> get ( name , value ) (Any) \u2014 Get the value of a key name </> pop ( name , *value ) (Any) \u2014 Pop a key from the object and return the value. If key does notexist, return the given default value </> popitem ( ) (Tuple) \u2014 Pop last item from the object </> setdefault ( name , value ) (Any) \u2014 Set a default value to a key </> thaw ( recursive ) \u2014 A context manager for temporarily change the diot </> to_dict ( ) (Dict) \u2014 Turn the Box and sub Boxes back into a nativepython dictionary. </> to_json ( filename , encoding , errors , **json_kwargs ) (Optional) \u2014 Convert to a json string or save it to json file </> to_toml ( filename , encoding , errors ) (Optional) \u2014 Convert to a toml string or save it to toml file </> to_yaml ( filename , default_flow_style , encoding , errors , **yaml_kwargs ) (Optional) \u2014 Convert to a yaml string or save it to yaml file </> unfreeze ( recursive ) \u2014 Unfreeze the diot object </> update ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> update_recursively ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> classmethod","title":"diot.diot.CamelDiot"},{"location":"api/diot.diot/#diotdiotdiotfrom_namespace_1","text":"</> Get a Diot object from an argparse namespace Example ~~~python from argparse import Namespace Diot.from_namespace(Namespace(a=1, b=2)) ~~~ Parameters namespace (Namespace) \u2014 The namespace object recursive (bool, optional) \u2014 Do it recursively? diot_nest (Union, optional) \u2014 Types to nestly convert values diot_transform (Union, optional) \u2014 The transforms for keys diot_frozen (Union, optional) \u2014 Whether to generate a frozen diot. - True: freeze the object recursively if there are Diot objects in descendants - False: Don'f freeze - shallow : Only freeze at depth = 1 diot_missing (Any, optional) \u2014 How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Returns ( Diot ) The converted diot object. method","title":"diot.diot.Diot.from_namespace"},{"location":"api/diot.diot/#diotdiotdiotsetitem_1","text":"</> Set self[key] to value. method","title":"diot.diot.Diot.setitem"},{"location":"api/diot.diot/#diotdiotdiotgetitem_1","text":"</> Return self[key]. method","title":"diot.diot.Diot.getitem"},{"location":"api/diot.diot/#diotdiotdiotpop_1","text":"</> Pop a key from the object and return the value. If key does notexist, return the given default value Parameters name (str) \u2014 The key Returns (Any) The value corresponding to the name or the default value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method","title":"diot.diot.Diot.pop"},{"location":"api/diot.diot/#diotdiotdiotpopitem_1","text":"</> Pop last item from the object Returns (Tuple) A tuple of key and value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method","title":"diot.diot.Diot.popitem"},{"location":"api/diot.diot/#diotdiotdiotupdate_1","text":"</> Update the object. Shortcut: |= Raises DiotFrozenError \u2014 when try to update a frozen diot method","title":"diot.diot.Diot.update"},{"location":"api/diot.diot/#diotdiotdiotupdate_recursively_1","text":"</> Update the object. Shortcut: |= Raises DiotFrozenError \u2014 when try to update a frozen diot method","title":"diot.diot.Diot.update_recursively"},{"location":"api/diot.diot/#diotdiotdiotior_1","text":"</> Return self|=value. method","title":"diot.diot.Diot.ior"},{"location":"api/diot.diot/#diotdiotdiotdelitem_1","text":"</> Delete self[key]. method","title":"diot.diot.Diot.delitem"},{"location":"api/diot.diot/#diotdiotdiotfreeze_1","text":"</> Freeze the diot object Parameters frozen (Union, optional) \u2014 The frozen argument indicating how to freeze:shallow: only freeze at depth=1 True: freeze recursively if there are diot objects in children False: Disable freezing method","title":"diot.diot.Diot.freeze"},{"location":"api/diot.diot/#diotdiotdiotunfreeze_1","text":"</> Unfreeze the diot object Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively generator","title":"diot.diot.Diot.unfreeze"},{"location":"api/diot.diot/#diotdiotdiotthaw_1","text":"</> A context manager for temporarily change the diot Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively Yields self, the reference to this diot. method","title":"diot.diot.Diot.thaw"},{"location":"api/diot.diot/#diotdiotdiotsetdefault_1","text":"</> Set a default value to a key Parameters name (str) \u2014 The key name value (Any) \u2014 The default value Returns (Any) The existing value or the value passed in Raises DiotFrozenError \u2014 when try to set default to a frozen diot method","title":"diot.diot.Diot.setdefault"},{"location":"api/diot.diot/#diotdiotdiotaccessible_keys_1","text":"</> Get the converted keys Returns (Iterable) The accessible (transformed) keys method","title":"diot.diot.Diot.accessible_keys"},{"location":"api/diot.diot/#diotdiotdiotget_1","text":"</> Get the value of a key name Parameters name (str) \u2014 The key name value (Any, optional) \u2014 The value to return if the key does not exist Returns (Any) The corresponding value or the value passed in if the key doesnot exist method","title":"diot.diot.Diot.get"},{"location":"api/diot.diot/#diotdiotdiotcontains_1","text":"</> True if the dictionary has the specified key, else False. method","title":"diot.diot.Diot.contains"},{"location":"api/diot.diot/#diotdiotdiotclear_1","text":"</> Clear the object method","title":"diot.diot.Diot.clear"},{"location":"api/diot.diot/#diotdiotdiotcopy_1","text":"</> Shallow copy the object Returns ( Diot ) The copied object method","title":"diot.diot.Diot.copy"},{"location":"api/diot.diot/#diotdiotdiotto_dict_1","text":"</> Turn the Box and sub Boxes back into a nativepython dictionary. Returns (Dict) The converted python dictionary method","title":"diot.diot.Diot.to_dict"},{"location":"api/diot.diot/#diotdiotdiotto_json_1","text":"</> Convert to a json string or save it to json file Parameters filename (Union, optional) \u2014 The filename to save the json to, if not given a jsonstring will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function **json_kwargs \u2014 Other kwargs for json.dumps Returns (Optional) The json string with filename is not given method","title":"diot.diot.Diot.to_json"},{"location":"api/diot.diot/#diotdiotdiotto_yaml_1","text":"</> Convert to a yaml string or save it to yaml file Parameters filename (Union, optional) \u2014 The filename to save the yaml to, if not given a yamlstring will be returned default_flow_style (bool, optional) \u2014 The default flow style for yaml dumpingSee yaml.dump encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function **yaml_kwargs \u2014 Other kwargs for yaml.dump Returns (Optional) The yaml string with filename is not given method","title":"diot.diot.Diot.to_yaml"},{"location":"api/diot.diot/#diotdiotdiotto_toml_1","text":"</> Convert to a toml string or save it to toml file Parameters filename (Union, optional) \u2014 The filename to save the toml to, if not given a tomlstring will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function Returns (Optional) The toml string with filename is not given class","title":"diot.diot.Diot.to_toml"},{"location":"api/diot.diot/#diotdiotsnakediot","text":"</> Bases diot.diot.Diot dict With snake case conversion Parameters *args \u2014 Anything that can be sent to dict construct **kwargs \u2014 keyword argument that can be sent to dict constructSome diot configurations can also be passed, including: diot_nest: Types to nestly convert values diot_transform: The transforms for keys diot_frozen: Whether to generate a frozen diot. True: freeze the object recursively if there are Diot objects in descendants False: Don'f freeze 'shallow': Only freeze at depth = 1 diot_missing: How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Methods __contains__ ( name ) (bool) \u2014 True if the dictionary has the specified key, else False. </> __delitem__ ( name ) \u2014 Delete self[key]. </> __getitem__ ( name ) (Any) \u2014 Return self[key]. </> __ior__ ( other ) ( Diot ) \u2014 Return self|=value. </> __setitem__ ( name , value ) \u2014 Set self[key] to value. </> accessible_keys ( ) (Iterable) \u2014 Get the converted keys </> clear ( ) \u2014 Clear the object </> copy ( ) ( Diot ) \u2014 Shallow copy the object </> freeze ( frozen ) \u2014 Freeze the diot object </> from_namespace ( namespace , recursive , diot_nest , diot_transform , diot_frozen , diot_missing ) ( Diot ) \u2014 Get a Diot object from an argparse namespace </> get ( name , value ) (Any) \u2014 Get the value of a key name </> pop ( name , *value ) (Any) \u2014 Pop a key from the object and return the value. If key does notexist, return the given default value </> popitem ( ) (Tuple) \u2014 Pop last item from the object </> setdefault ( name , value ) (Any) \u2014 Set a default value to a key </> thaw ( recursive ) \u2014 A context manager for temporarily change the diot </> to_dict ( ) (Dict) \u2014 Turn the Box and sub Boxes back into a nativepython dictionary. </> to_json ( filename , encoding , errors , **json_kwargs ) (Optional) \u2014 Convert to a json string or save it to json file </> to_toml ( filename , encoding , errors ) (Optional) \u2014 Convert to a toml string or save it to toml file </> to_yaml ( filename , default_flow_style , encoding , errors , **yaml_kwargs ) (Optional) \u2014 Convert to a yaml string or save it to yaml file </> unfreeze ( recursive ) \u2014 Unfreeze the diot object </> update ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> update_recursively ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> classmethod","title":"diot.diot.SnakeDiot"},{"location":"api/diot.diot/#diotdiotdiotfrom_namespace_2","text":"</> Get a Diot object from an argparse namespace Example ~~~python from argparse import Namespace Diot.from_namespace(Namespace(a=1, b=2)) ~~~ Parameters namespace (Namespace) \u2014 The namespace object recursive (bool, optional) \u2014 Do it recursively? diot_nest (Union, optional) \u2014 Types to nestly convert values diot_transform (Union, optional) \u2014 The transforms for keys diot_frozen (Union, optional) \u2014 Whether to generate a frozen diot. - True: freeze the object recursively if there are Diot objects in descendants - False: Don'f freeze - shallow : Only freeze at depth = 1 diot_missing (Any, optional) \u2014 How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Returns ( Diot ) The converted diot object. method","title":"diot.diot.Diot.from_namespace"},{"location":"api/diot.diot/#diotdiotdiotsetitem_2","text":"</> Set self[key] to value. method","title":"diot.diot.Diot.setitem"},{"location":"api/diot.diot/#diotdiotdiotgetitem_2","text":"</> Return self[key]. method","title":"diot.diot.Diot.getitem"},{"location":"api/diot.diot/#diotdiotdiotpop_2","text":"</> Pop a key from the object and return the value. If key does notexist, return the given default value Parameters name (str) \u2014 The key Returns (Any) The value corresponding to the name or the default value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method","title":"diot.diot.Diot.pop"},{"location":"api/diot.diot/#diotdiotdiotpopitem_2","text":"</> Pop last item from the object Returns (Tuple) A tuple of key and value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method","title":"diot.diot.Diot.popitem"},{"location":"api/diot.diot/#diotdiotdiotupdate_2","text":"</> Update the object. Shortcut: |= Raises DiotFrozenError \u2014 when try to update a frozen diot method","title":"diot.diot.Diot.update"},{"location":"api/diot.diot/#diotdiotdiotupdate_recursively_2","text":"</> Update the object. Shortcut: |= Raises DiotFrozenError \u2014 when try to update a frozen diot method","title":"diot.diot.Diot.update_recursively"},{"location":"api/diot.diot/#diotdiotdiotior_2","text":"</> Return self|=value. method","title":"diot.diot.Diot.ior"},{"location":"api/diot.diot/#diotdiotdiotdelitem_2","text":"</> Delete self[key]. method","title":"diot.diot.Diot.delitem"},{"location":"api/diot.diot/#diotdiotdiotfreeze_2","text":"</> Freeze the diot object Parameters frozen (Union, optional) \u2014 The frozen argument indicating how to freeze:shallow: only freeze at depth=1 True: freeze recursively if there are diot objects in children False: Disable freezing method","title":"diot.diot.Diot.freeze"},{"location":"api/diot.diot/#diotdiotdiotunfreeze_2","text":"</> Unfreeze the diot object Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively generator","title":"diot.diot.Diot.unfreeze"},{"location":"api/diot.diot/#diotdiotdiotthaw_2","text":"</> A context manager for temporarily change the diot Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively Yields self, the reference to this diot. method","title":"diot.diot.Diot.thaw"},{"location":"api/diot.diot/#diotdiotdiotsetdefault_2","text":"</> Set a default value to a key Parameters name (str) \u2014 The key name value (Any) \u2014 The default value Returns (Any) The existing value or the value passed in Raises DiotFrozenError \u2014 when try to set default to a frozen diot method","title":"diot.diot.Diot.setdefault"},{"location":"api/diot.diot/#diotdiotdiotaccessible_keys_2","text":"</> Get the converted keys Returns (Iterable) The accessible (transformed) keys method","title":"diot.diot.Diot.accessible_keys"},{"location":"api/diot.diot/#diotdiotdiotget_2","text":"</> Get the value of a key name Parameters name (str) \u2014 The key name value (Any, optional) \u2014 The value to return if the key does not exist Returns (Any) The corresponding value or the value passed in if the key doesnot exist method","title":"diot.diot.Diot.get"},{"location":"api/diot.diot/#diotdiotdiotcontains_2","text":"</> True if the dictionary has the specified key, else False. method","title":"diot.diot.Diot.contains"},{"location":"api/diot.diot/#diotdiotdiotclear_2","text":"</> Clear the object method","title":"diot.diot.Diot.clear"},{"location":"api/diot.diot/#diotdiotdiotcopy_2","text":"</> Shallow copy the object Returns ( Diot ) The copied object method","title":"diot.diot.Diot.copy"},{"location":"api/diot.diot/#diotdiotdiotto_dict_2","text":"</> Turn the Box and sub Boxes back into a nativepython dictionary. Returns (Dict) The converted python dictionary method","title":"diot.diot.Diot.to_dict"},{"location":"api/diot.diot/#diotdiotdiotto_json_2","text":"</> Convert to a json string or save it to json file Parameters filename (Union, optional) \u2014 The filename to save the json to, if not given a jsonstring will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function **json_kwargs \u2014 Other kwargs for json.dumps Returns (Optional) The json string with filename is not given method","title":"diot.diot.Diot.to_json"},{"location":"api/diot.diot/#diotdiotdiotto_yaml_2","text":"</> Convert to a yaml string or save it to yaml file Parameters filename (Union, optional) \u2014 The filename to save the yaml to, if not given a yamlstring will be returned default_flow_style (bool, optional) \u2014 The default flow style for yaml dumpingSee yaml.dump encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function **yaml_kwargs \u2014 Other kwargs for yaml.dump Returns (Optional) The yaml string with filename is not given method","title":"diot.diot.Diot.to_yaml"},{"location":"api/diot.diot/#diotdiotdiotto_toml_2","text":"</> Convert to a toml string or save it to toml file Parameters filename (Union, optional) \u2014 The filename to save the toml to, if not given a tomlstring will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function Returns (Optional) The toml string with filename is not given class","title":"diot.diot.Diot.to_toml"},{"location":"api/diot.diot/#diotdiotfrozendiot","text":"</> Bases diot.diot.Diot dict The frozen diot Parameters *args \u2014 Anything that can be sent to dict construct **kwargs \u2014 keyword argument that can be sent to dict constructSome diot configurations can also be passed, including: diot_nest: Types to nestly convert values diot_transform: The transforms for keys diot_frozen: Whether to generate a frozen diot. True: freeze the object recursively if there are Diot objects in descendants False: Don'f freeze 'shallow': Only freeze at depth = 1 diot_missing: How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Methods __contains__ ( name ) (bool) \u2014 True if the dictionary has the specified key, else False. </> __delitem__ ( name ) \u2014 Delete self[key]. </> __getitem__ ( name ) (Any) \u2014 Return self[key]. </> __ior__ ( other ) ( Diot ) \u2014 Return self|=value. </> __setitem__ ( name , value ) \u2014 Set self[key] to value. </> accessible_keys ( ) (Iterable) \u2014 Get the converted keys </> clear ( ) \u2014 Clear the object </> copy ( ) ( Diot ) \u2014 Shallow copy the object </> freeze ( frozen ) \u2014 Freeze the diot object </> from_namespace ( namespace , recursive , diot_nest , diot_transform , diot_frozen , diot_missing ) ( Diot ) \u2014 Get a Diot object from an argparse namespace </> get ( name , value ) (Any) \u2014 Get the value of a key name </> pop ( name , *value ) (Any) \u2014 Pop a key from the object and return the value. If key does notexist, return the given default value </> popitem ( ) (Tuple) \u2014 Pop last item from the object </> setdefault ( name , value ) (Any) \u2014 Set a default value to a key </> thaw ( recursive ) \u2014 A context manager for temporarily change the diot </> to_dict ( ) (Dict) \u2014 Turn the Box and sub Boxes back into a nativepython dictionary. </> to_json ( filename , encoding , errors , **json_kwargs ) (Optional) \u2014 Convert to a json string or save it to json file </> to_toml ( filename , encoding , errors ) (Optional) \u2014 Convert to a toml string or save it to toml file </> to_yaml ( filename , default_flow_style , encoding , errors , **yaml_kwargs ) (Optional) \u2014 Convert to a yaml string or save it to yaml file </> unfreeze ( recursive ) \u2014 Unfreeze the diot object </> update ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> update_recursively ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> classmethod","title":"diot.diot.FrozenDiot"},{"location":"api/diot.diot/#diotdiotdiotfrom_namespace_3","text":"</> Get a Diot object from an argparse namespace Example ~~~python from argparse import Namespace Diot.from_namespace(Namespace(a=1, b=2)) ~~~ Parameters namespace (Namespace) \u2014 The namespace object recursive (bool, optional) \u2014 Do it recursively? diot_nest (Union, optional) \u2014 Types to nestly convert values diot_transform (Union, optional) \u2014 The transforms for keys diot_frozen (Union, optional) \u2014 Whether to generate a frozen diot. - True: freeze the object recursively if there are Diot objects in descendants - False: Don'f freeze - shallow : Only freeze at depth = 1 diot_missing (Any, optional) \u2014 How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Returns ( Diot ) The converted diot object. method","title":"diot.diot.Diot.from_namespace"},{"location":"api/diot.diot/#diotdiotdiotsetitem_3","text":"</> Set self[key] to value. method","title":"diot.diot.Diot.setitem"},{"location":"api/diot.diot/#diotdiotdiotgetitem_3","text":"</> Return self[key]. method","title":"diot.diot.Diot.getitem"},{"location":"api/diot.diot/#diotdiotdiotpop_3","text":"</> Pop a key from the object and return the value. If key does notexist, return the given default value Parameters name (str) \u2014 The key Returns (Any) The value corresponding to the name or the default value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method","title":"diot.diot.Diot.pop"},{"location":"api/diot.diot/#diotdiotdiotpopitem_3","text":"</> Pop last item from the object Returns (Tuple) A tuple of key and value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method","title":"diot.diot.Diot.popitem"},{"location":"api/diot.diot/#diotdiotdiotupdate_3","text":"</> Update the object. Shortcut: |= Raises DiotFrozenError \u2014 when try to update a frozen diot method","title":"diot.diot.Diot.update"},{"location":"api/diot.diot/#diotdiotdiotupdate_recursively_3","text":"</> Update the object. Shortcut: |= Raises DiotFrozenError \u2014 when try to update a frozen diot method","title":"diot.diot.Diot.update_recursively"},{"location":"api/diot.diot/#diotdiotdiotior_3","text":"</> Return self|=value. method","title":"diot.diot.Diot.ior"},{"location":"api/diot.diot/#diotdiotdiotdelitem_3","text":"</> Delete self[key]. method","title":"diot.diot.Diot.delitem"},{"location":"api/diot.diot/#diotdiotdiotfreeze_3","text":"</> Freeze the diot object Parameters frozen (Union, optional) \u2014 The frozen argument indicating how to freeze:shallow: only freeze at depth=1 True: freeze recursively if there are diot objects in children False: Disable freezing method","title":"diot.diot.Diot.freeze"},{"location":"api/diot.diot/#diotdiotdiotunfreeze_3","text":"</> Unfreeze the diot object Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively generator","title":"diot.diot.Diot.unfreeze"},{"location":"api/diot.diot/#diotdiotdiotthaw_3","text":"</> A context manager for temporarily change the diot Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively Yields self, the reference to this diot. method","title":"diot.diot.Diot.thaw"},{"location":"api/diot.diot/#diotdiotdiotsetdefault_3","text":"</> Set a default value to a key Parameters name (str) \u2014 The key name value (Any) \u2014 The default value Returns (Any) The existing value or the value passed in Raises DiotFrozenError \u2014 when try to set default to a frozen diot method","title":"diot.diot.Diot.setdefault"},{"location":"api/diot.diot/#diotdiotdiotaccessible_keys_3","text":"</> Get the converted keys Returns (Iterable) The accessible (transformed) keys method","title":"diot.diot.Diot.accessible_keys"},{"location":"api/diot.diot/#diotdiotdiotget_3","text":"</> Get the value of a key name Parameters name (str) \u2014 The key name value (Any, optional) \u2014 The value to return if the key does not exist Returns (Any) The corresponding value or the value passed in if the key doesnot exist method","title":"diot.diot.Diot.get"},{"location":"api/diot.diot/#diotdiotdiotcontains_3","text":"</> True if the dictionary has the specified key, else False. method","title":"diot.diot.Diot.contains"},{"location":"api/diot.diot/#diotdiotdiotclear_3","text":"</> Clear the object method","title":"diot.diot.Diot.clear"},{"location":"api/diot.diot/#diotdiotdiotcopy_3","text":"</> Shallow copy the object Returns ( Diot ) The copied object method","title":"diot.diot.Diot.copy"},{"location":"api/diot.diot/#diotdiotdiotto_dict_3","text":"</> Turn the Box and sub Boxes back into a nativepython dictionary. Returns (Dict) The converted python dictionary method","title":"diot.diot.Diot.to_dict"},{"location":"api/diot.diot/#diotdiotdiotto_json_3","text":"</> Convert to a json string or save it to json file Parameters filename (Union, optional) \u2014 The filename to save the json to, if not given a jsonstring will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function **json_kwargs \u2014 Other kwargs for json.dumps Returns (Optional) The json string with filename is not given method","title":"diot.diot.Diot.to_json"},{"location":"api/diot.diot/#diotdiotdiotto_yaml_3","text":"</> Convert to a yaml string or save it to yaml file Parameters filename (Union, optional) \u2014 The filename to save the yaml to, if not given a yamlstring will be returned default_flow_style (bool, optional) \u2014 The default flow style for yaml dumpingSee yaml.dump encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function **yaml_kwargs \u2014 Other kwargs for yaml.dump Returns (Optional) The yaml string with filename is not given method","title":"diot.diot.Diot.to_yaml"},{"location":"api/diot.diot/#diotdiotdiotto_toml_3","text":"</> Convert to a toml string or save it to toml file Parameters filename (Union, optional) \u2014 The filename to save the toml to, if not given a tomlstring will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function Returns (Optional) The toml string with filename is not given class","title":"diot.diot.Diot.to_toml"},{"location":"api/diot.diot/#diotdiotordereddiot","text":"</> Bases diot.diot.Diot dict With key order preserved Parameters *args \u2014 Anything that can be sent to dict construct **kwargs \u2014 keyword argument that can be sent to dict constructSome diot configurations can also be passed, including: diot_nest: Types to nestly convert values diot_transform: The transforms for keys diot_frozen: Whether to generate a frozen diot. True: freeze the object recursively if there are Diot objects in descendants False: Don'f freeze 'shallow': Only freeze at depth = 1 diot_missing: How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Methods __contains__ ( name ) (bool) \u2014 True if the dictionary has the specified key, else False. </> __delitem__ ( name ) \u2014 Delete self[key]. </> __getitem__ ( name ) (Any) \u2014 Return self[key]. </> __ior__ ( other ) ( Diot ) \u2014 Return self|=value. </> __iter__ ( ) (Iterable) \u2014 Implement iter(self). </> __reversed__ ( ) (Iterable) \u2014 Return a reverse iterator over the dict keys. </> __setitem__ ( name , value ) \u2014 Set self[key] to value. </> accessible_keys ( ) (Iterable) \u2014 Get the converted keys </> clear ( ) \u2014 Clear the object </> copy ( ) ( Diot ) \u2014 Shallow copy the object </> copy ( ) ( OrderedDiot ) \u2014 Shallow copy the object </> freeze ( frozen ) \u2014 Freeze the diot object </> from_namespace ( namespace , recursive , diot_nest , diot_transform , diot_frozen , diot_missing ) ( Diot ) \u2014 Get a Diot object from an argparse namespace </> get ( name , value ) (Any) \u2014 Get the value of a key name </> insert ( position , name , value ) \u2014 Insert an item to certain position </> insert_after ( existing_key , name , value ) \u2014 Insert items after the specified key </> insert_before ( existing_key , name , value ) \u2014 Insert items before the specified key </> items ( ) (Iterator) \u2014 Get the items in the order of the keys </> keys ( ) (Iterable) \u2014 Get the keys in the order they are added </> pop ( name , *value ) (Any) \u2014 Pop a key from the object and return the value. If key does notexist, return the given default value </> popitem ( ) (Tuple) \u2014 Pop last item from the object </> setdefault ( name , value ) (Any) \u2014 Set a default value to a key </> thaw ( recursive ) \u2014 A context manager for temporarily change the diot </> to_dict ( ) (Dict) \u2014 Turn the Box and sub Boxes back into a nativepython dictionary. </> to_json ( filename , encoding , errors , **json_kwargs ) (Optional) \u2014 Convert to a json string or save it to json file </> to_toml ( filename , encoding , errors ) (Optional) \u2014 Convert to a toml string or save it to toml file </> to_yaml ( filename , default_flow_style , encoding , errors , **yaml_kwargs ) (Optional) \u2014 Convert to a yaml string or save it to yaml file </> unfreeze ( recursive ) \u2014 Unfreeze the diot object </> update ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> update_recursively ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> values ( ) (Iterable) \u2014 Get the values in the order they are added </> classmethod","title":"diot.diot.OrderedDiot"},{"location":"api/diot.diot/#diotdiotdiotfrom_namespace_4","text":"</> Get a Diot object from an argparse namespace Example ~~~python from argparse import Namespace Diot.from_namespace(Namespace(a=1, b=2)) ~~~ Parameters namespace (Namespace) \u2014 The namespace object recursive (bool, optional) \u2014 Do it recursively? diot_nest (Union, optional) \u2014 Types to nestly convert values diot_transform (Union, optional) \u2014 The transforms for keys diot_frozen (Union, optional) \u2014 Whether to generate a frozen diot. - True: freeze the object recursively if there are Diot objects in descendants - False: Don'f freeze - shallow : Only freeze at depth = 1 diot_missing (Any, optional) \u2014 How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Returns ( Diot ) The converted diot object. method","title":"diot.diot.Diot.from_namespace"},{"location":"api/diot.diot/#diotdiotdiotgetitem_4","text":"</> Return self[key]. method","title":"diot.diot.Diot.getitem"},{"location":"api/diot.diot/#diotdiotdiotpopitem_4","text":"</> Pop last item from the object Returns (Tuple) A tuple of key and value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method","title":"diot.diot.Diot.popitem"},{"location":"api/diot.diot/#diotdiotdiotupdate_4","text":"</> Update the object. Shortcut: |= Raises DiotFrozenError \u2014 when try to update a frozen diot method","title":"diot.diot.Diot.update"},{"location":"api/diot.diot/#diotdiotdiotupdate_recursively_4","text":"</> Update the object. Shortcut: |= Raises DiotFrozenError \u2014 when try to update a frozen diot method","title":"diot.diot.Diot.update_recursively"},{"location":"api/diot.diot/#diotdiotdiotior_4","text":"</> Return self|=value. method","title":"diot.diot.Diot.ior"},{"location":"api/diot.diot/#diotdiotdiotfreeze_4","text":"</> Freeze the diot object Parameters frozen (Union, optional) \u2014 The frozen argument indicating how to freeze:shallow: only freeze at depth=1 True: freeze recursively if there are diot objects in children False: Disable freezing method","title":"diot.diot.Diot.freeze"},{"location":"api/diot.diot/#diotdiotdiotunfreeze_4","text":"</> Unfreeze the diot object Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively generator","title":"diot.diot.Diot.unfreeze"},{"location":"api/diot.diot/#diotdiotdiotthaw_4","text":"</> A context manager for temporarily change the diot Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively Yields self, the reference to this diot. method","title":"diot.diot.Diot.thaw"},{"location":"api/diot.diot/#diotdiotdiotsetdefault_4","text":"</> Set a default value to a key Parameters name (str) \u2014 The key name value (Any) \u2014 The default value Returns (Any) The existing value or the value passed in Raises DiotFrozenError \u2014 when try to set default to a frozen diot method","title":"diot.diot.Diot.setdefault"},{"location":"api/diot.diot/#diotdiotdiotaccessible_keys_4","text":"</> Get the converted keys Returns (Iterable) The accessible (transformed) keys method","title":"diot.diot.Diot.accessible_keys"},{"location":"api/diot.diot/#diotdiotdiotget_4","text":"</> Get the value of a key name Parameters name (str) \u2014 The key name value (Any, optional) \u2014 The value to return if the key does not exist Returns (Any) The corresponding value or the value passed in if the key doesnot exist method","title":"diot.diot.Diot.get"},{"location":"api/diot.diot/#diotdiotdiotcontains_4","text":"</> True if the dictionary has the specified key, else False. method","title":"diot.diot.Diot.contains"},{"location":"api/diot.diot/#diotdiotdiotcopy_4","text":"</> Shallow copy the object Returns ( Diot ) The copied object method","title":"diot.diot.Diot.copy"},{"location":"api/diot.diot/#diotdiotdiotto_dict_4","text":"</> Turn the Box and sub Boxes back into a nativepython dictionary. Returns (Dict) The converted python dictionary method","title":"diot.diot.Diot.to_dict"},{"location":"api/diot.diot/#diotdiotdiotto_json_4","text":"</> Convert to a json string or save it to json file Parameters filename (Union, optional) \u2014 The filename to save the json to, if not given a jsonstring will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function **json_kwargs \u2014 Other kwargs for json.dumps Returns (Optional) The json string with filename is not given method","title":"diot.diot.Diot.to_json"},{"location":"api/diot.diot/#diotdiotdiotto_yaml_4","text":"</> Convert to a yaml string or save it to yaml file Parameters filename (Union, optional) \u2014 The filename to save the yaml to, if not given a yamlstring will be returned default_flow_style (bool, optional) \u2014 The default flow style for yaml dumpingSee yaml.dump encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function **yaml_kwargs \u2014 Other kwargs for yaml.dump Returns (Optional) The yaml string with filename is not given method","title":"diot.diot.Diot.to_yaml"},{"location":"api/diot.diot/#diotdiotdiotto_toml_4","text":"</> Convert to a toml string or save it to toml file Parameters filename (Union, optional) \u2014 The filename to save the toml to, if not given a tomlstring will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to fileSee python's open function Returns (Optional) The toml string with filename is not given method","title":"diot.diot.Diot.to_toml"},{"location":"api/diot.diot/#diotdiotordereddiotsetitem","text":"</> Set self[key] to value. method","title":"diot.diot.OrderedDiot.setitem"},{"location":"api/diot.diot/#diotdiotordereddiotitems","text":"</> Get the items in the order of the keys Returns (Iterator) The items (key-value) of the object method","title":"diot.diot.OrderedDiot.items"},{"location":"api/diot.diot/#diotdiotordereddiotinsert","text":"</> Insert an item to certain position Parameters position (int) \u2014 The position where the name-value pair to be inserted name (Union) \u2014 The key name to be insertedIt could also be a tuple of key-value pair. In such a case, value is ignored. It could be an ordered dictionary as well value (Any, optional) \u2014 The value to be inserted Raises ValueError \u2014 when try to pass a value if name is key-value pair ora dictonary. ValueError \u2014 when name is a tuple but not with 2 elements method","title":"diot.diot.OrderedDiot.insert"},{"location":"api/diot.diot/#diotdiotordereddiotinsert_before","text":"</> Insert items before the specified key Parameters existing_key (str) \u2014 The key where the new elements to be inserted before name (str) \u2014 The key name to be inserted value (Any, optional) \u2014 The value to be insertedSame as name and value arguments for insert Raises KeyError \u2014 when existing key does not exist KeyError \u2014 when name is an existing key method","title":"diot.diot.OrderedDiot.insert_before"},{"location":"api/diot.diot/#diotdiotordereddiotinsert_after","text":"</> Insert items after the specified key Parameters existing_key (str) \u2014 The key where the new elements to be inserted after name (str) \u2014 The key name to be inserted value (Any, optional) \u2014 The value to be insertedSame as name and value arguments for insert Raises KeyError \u2014 when existing key does not exist KeyError \u2014 when name is an existing key method","title":"diot.diot.OrderedDiot.insert_after"},{"location":"api/diot.diot/#diotdiotordereddiotkeys","text":"</> Get the keys in the order they are added Returns (Iterable) The keys (untransformed) method","title":"diot.diot.OrderedDiot.keys"},{"location":"api/diot.diot/#diotdiotordereddiotiter","text":"</> Implement iter(self). method","title":"diot.diot.OrderedDiot.iter"},{"location":"api/diot.diot/#diotdiotordereddiotvalues","text":"</> Get the values in the order they are added Returns (Iterable) The values of the object method","title":"diot.diot.OrderedDiot.values"},{"location":"api/diot.diot/#diotdiotordereddiotdelitem","text":"</> Delete self[key]. method","title":"diot.diot.OrderedDiot.delitem"},{"location":"api/diot.diot/#diotdiotordereddiotpop","text":"</> Pop a key from the object and return the value. If key does notexist, return the given default value Parameters name (str) \u2014 The key Returns (Any) The value corresponding to the name or the default value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method","title":"diot.diot.OrderedDiot.pop"},{"location":"api/diot.diot/#diotdiotordereddiotreversed","text":"</> Return a reverse iterator over the dict keys. method","title":"diot.diot.OrderedDiot.reversed"},{"location":"api/diot.diot/#diotdiotordereddiotclear","text":"</> Clear the object method","title":"diot.diot.OrderedDiot.clear"},{"location":"api/diot.diot/#diotdiotordereddiotcopy","text":"</> Shallow copy the object Returns ( OrderedDiot ) The copied object","title":"diot.diot.OrderedDiot.copy"},{"location":"api/diot/","text":"package diot </> Dot notation and access for dictionaries in python module diot . diot </> diot module Classes Diot \u2014 Dictionary with dot notation </> CamelDiot \u2014 With camel case conversion </> SnakeDiot \u2014 With snake case conversion </> FrozenDiot \u2014 The frozen diot </> OrderedDiot \u2014 With key order preserved </> module diot . transforms </> Key transforms for diot @Attribute: TRANSFORMS: Builtin transforms Functions camel_case ( item ) (str) \u2014 Transform item to camel case format </> lower_case ( item ) (str) \u2014 Transform item to lower case </> safe_transform ( item ) (str) \u2014 Transform an arbitrary key into a safe key for dot notation </> snake_case ( item ) (str) \u2014 Transform item to snake case </> upper_case ( item ) (str) \u2014 Transform item to upper case </> module diot . utils </> Utilities for diot Classes DiotFrozenError \u2014 When try to modify a frozen diot </> Functions nest ( value , types , dest_type , frozen ) (Any) \u2014 Convert values with certain types recursively </> to_dict ( value ) (dict) \u2014 Convert converted Diot objects back to dict </>","title":"diot"},{"location":"api/diot/#diot","text":"</> Dot notation and access for dictionaries in python module","title":"diot"},{"location":"api/diot/#diotdiot","text":"</> diot module Classes Diot \u2014 Dictionary with dot notation </> CamelDiot \u2014 With camel case conversion </> SnakeDiot \u2014 With snake case conversion </> FrozenDiot \u2014 The frozen diot </> OrderedDiot \u2014 With key order preserved </> module","title":"diot.diot"},{"location":"api/diot/#diottransforms","text":"</> Key transforms for diot @Attribute: TRANSFORMS: Builtin transforms Functions camel_case ( item ) (str) \u2014 Transform item to camel case format </> lower_case ( item ) (str) \u2014 Transform item to lower case </> safe_transform ( item ) (str) \u2014 Transform an arbitrary key into a safe key for dot notation </> snake_case ( item ) (str) \u2014 Transform item to snake case </> upper_case ( item ) (str) \u2014 Transform item to upper case </> module","title":"diot.transforms"},{"location":"api/diot/#diotutils","text":"</> Utilities for diot Classes DiotFrozenError \u2014 When try to modify a frozen diot </> Functions nest ( value , types , dest_type , frozen ) (Any) \u2014 Convert values with certain types recursively </> to_dict ( value ) (dict) \u2014 Convert converted Diot objects back to dict </>","title":"diot.utils"},{"location":"api/diot.transforms/","text":"module diot . transforms </> Key transforms for diot @Attribute: TRANSFORMS: Builtin transforms Functions camel_case ( item ) (str) \u2014 Transform item to camel case format </> lower_case ( item ) (str) \u2014 Transform item to lower case </> safe_transform ( item ) (str) \u2014 Transform an arbitrary key into a safe key for dot notation </> snake_case ( item ) (str) \u2014 Transform item to snake case </> upper_case ( item ) (str) \u2014 Transform item to upper case </> function diot.transforms . safe_transform ( item ) </> Transform an arbitrary key into a safe key for dot notation Examples ~~~python safe_transform(\"a,b\") # a_b safe_transform(\"a_,_b\") # a__b safe_transform(\"in\") # _in ~~~ Parameters item (str) \u2014 The item to be transformed Returns (str) The safely-transformed item function diot.transforms . camel_case ( item ) </> Transform item to camel case format The item will be first safely-transformed. Examples ~~~python camel_case('one_two') # oneTwo camel_case('_one') # _one camel_case('o_one') # oOne ~~~ Parameters item (str) \u2014 The item to be transformed Returns (str) The camel_case-transformed item function diot.transforms . snake_case ( item ) </> Transform item to snake case The item will be first safely-transformed. Examples ~~~python snake_case('oneTwo') # one_two snake_case('One') # one snake_case('1One') # _1_one ~~~ Parameters item (str) \u2014 The item to be transformed Returns (str) The snake_case-transformed item function diot.transforms . upper_case ( item ) </> Transform item to upper case The item will be first safely-transformed. Examples ~~~python upper_case('oneTwo') # ONETWO upper_case('One') # ONE upper_case('1One') # _1ONE ~~~ Parameters item (str) \u2014 The item to be transformed Returns (str) The uppercase-transformed item function diot.transforms . lower_case ( item ) </> Transform item to lower case The item will be first safely-transformed. Examples ~~~python lower_case('ONETWO') # onetwo lower_case('One') # one lower_case('1One') # _1one ~~~ Parameters item (str) \u2014 The item to be transformed Returns (str) The lowercase-transformed item","title":"diot.transforms"},{"location":"api/diot.transforms/#diottransforms","text":"</> Key transforms for diot @Attribute: TRANSFORMS: Builtin transforms Functions camel_case ( item ) (str) \u2014 Transform item to camel case format </> lower_case ( item ) (str) \u2014 Transform item to lower case </> safe_transform ( item ) (str) \u2014 Transform an arbitrary key into a safe key for dot notation </> snake_case ( item ) (str) \u2014 Transform item to snake case </> upper_case ( item ) (str) \u2014 Transform item to upper case </> function","title":"diot.transforms"},{"location":"api/diot.transforms/#diottransformssafe_transform","text":"</> Transform an arbitrary key into a safe key for dot notation Examples ~~~python safe_transform(\"a,b\") # a_b safe_transform(\"a_,_b\") # a__b safe_transform(\"in\") # _in ~~~ Parameters item (str) \u2014 The item to be transformed Returns (str) The safely-transformed item function","title":"diot.transforms.safe_transform"},{"location":"api/diot.transforms/#diottransformscamel_case","text":"</> Transform item to camel case format The item will be first safely-transformed. Examples ~~~python camel_case('one_two') # oneTwo camel_case('_one') # _one camel_case('o_one') # oOne ~~~ Parameters item (str) \u2014 The item to be transformed Returns (str) The camel_case-transformed item function","title":"diot.transforms.camel_case"},{"location":"api/diot.transforms/#diottransformssnake_case","text":"</> Transform item to snake case The item will be first safely-transformed. Examples ~~~python snake_case('oneTwo') # one_two snake_case('One') # one snake_case('1One') # _1_one ~~~ Parameters item (str) \u2014 The item to be transformed Returns (str) The snake_case-transformed item function","title":"diot.transforms.snake_case"},{"location":"api/diot.transforms/#diottransformsupper_case","text":"</> Transform item to upper case The item will be first safely-transformed. Examples ~~~python upper_case('oneTwo') # ONETWO upper_case('One') # ONE upper_case('1One') # _1ONE ~~~ Parameters item (str) \u2014 The item to be transformed Returns (str) The uppercase-transformed item function","title":"diot.transforms.upper_case"},{"location":"api/diot.transforms/#diottransformslower_case","text":"</> Transform item to lower case The item will be first safely-transformed. Examples ~~~python lower_case('ONETWO') # onetwo lower_case('One') # one lower_case('1One') # _1one ~~~ Parameters item (str) \u2014 The item to be transformed Returns (str) The lowercase-transformed item","title":"diot.transforms.lower_case"},{"location":"api/diot.utils/","text":"module diot . utils </> Utilities for diot Classes DiotFrozenError \u2014 When try to modify a frozen diot </> Functions nest ( value , types , dest_type , frozen ) (Any) \u2014 Convert values with certain types recursively </> to_dict ( value ) (dict) \u2014 Convert converted Diot objects back to dict </> class diot.utils . DiotFrozenError ( ) </> Bases Exception BaseException When try to modify a frozen diot function diot.utils . nest ( value , types , dest_type , frozen ) \u2192 Any </> Convert values with certain types recursively function diot.utils . to_dict ( value ) \u2192 dict </> Convert converted Diot objects back to dict","title":"diot.utils"},{"location":"api/diot.utils/#diotutils","text":"</> Utilities for diot Classes DiotFrozenError \u2014 When try to modify a frozen diot </> Functions nest ( value , types , dest_type , frozen ) (Any) \u2014 Convert values with certain types recursively </> to_dict ( value ) (dict) \u2014 Convert converted Diot objects back to dict </> class","title":"diot.utils"},{"location":"api/diot.utils/#diotutilsdiotfrozenerror","text":"</> Bases Exception BaseException When try to modify a frozen diot function","title":"diot.utils.DiotFrozenError"},{"location":"api/diot.utils/#diotutilsnest","text":"</> Convert values with certain types recursively function","title":"diot.utils.nest"},{"location":"api/diot.utils/#diotutilsto_dict","text":"</> Convert converted Diot objects back to dict","title":"diot.utils.to_dict"},{"location":"api/source/diot.diot/","text":"SOURCE CODE diot. diot DOCS \"\"\"diot module\"\"\" from __future__ import annotations from contextlib import contextmanager from copy import deepcopy from os import PathLike from typing import ( TYPE_CHECKING , Any , Callable , Dict , Iterable , Iterator , Optional , Tuple , Union , ) from .transforms import TRANSFORMS from .utils import DiotFrozenError , nest , to_dict if TYPE_CHECKING : from argparse import Namespace class _DiotMissingDefault : \"\"\"The default value for diot_missing\"\"\" # Make it a singleton __slots__ = () __instance = None def __new__ ( cls ): if cls . __instance is None : cls . __instance = super () . __new__ ( cls ) return cls . __instance # The default value for diot_missing # When accessed with d.a, an AttributeError will be raised # When accessed with d['a'], a KeyError will be raised # This class makes it pickable than object DIOT_MISSING_DEFAULT = _DiotMissingDefault () class Diot ( dict ): DOCS \"\"\"Dictionary with dot notation Examples: >>> d = Diot(a=1, b=2) >>> d.a = 2 >>> d['a'] = 2 >>> d.a # 2 >>> d['a'] # 2 >>> d.pop('a') # 2 >>> d.pop('x', 1) # 1 >>> d.popitem() # ('b', 2) >>> d.update(a=3, b=4) # {'a': 3, 'b': 4} >>> d | {'a': 1, 'b': 2} # {'a': 1, 'b': 2} (d unchanged) >>> d |= {'a': 1, 'b': 2} # d == {'a': 1, 'b': 2} >>> del d.a >>> del d['b'] >>> d.freeze() >>> d.a = 1 # DiotFrozenError >>> d.unfreeze() >>> d.a = 1 # ok >>> d.setdefault('b', 2) >>> 'b' in d >>> d.copy() >>> d.deepcopy() Args: *args: Anything that can be sent to dict construct **kwargs: keyword argument that can be sent to dict construct Some diot configurations can also be passed, including: diot_nest: Types to nestly convert values diot_transform: The transforms for keys diot_frozen: Whether to generate a frozen diot. True: freeze the object recursively if there are Diot objects in descendants False: Don'f freeze 'shallow': Only freeze at depth = 1 diot_missing: How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly \"\"\" __slots__ = ( \"__diot__\" , \"__dict__\" ) def __new__ ( cls , * args , ** kwargs ): ret = super () . __new__ ( cls ) # unpickling will not call __init__ # we use a flag '__inited__' to tell if __init__ has been called # is there a better way? ret . __init__ ( * args , ** kwargs ) return ret @classmethod DOCS def from_namespace ( cls , namespace : Namespace , recursive : bool = True , diot_nest : Union [ bool , Iterable [ type ]] = True , diot_transform : Union [ Callable [[ str ], str ], str ] = \"safe\" , diot_frozen : Union [ bool , str ] = False , diot_missing : Any = DIOT_MISSING_DEFAULT , ) -> Diot : \"\"\"Get a Diot object from an argparse namespace Example: >>> from argparse import Namespace >>> Diot.from_namespace(Namespace(a=1, b=2)) Args: namespace: The namespace object recursive: Do it recursively? diot_nest: Types to nestly convert values diot_transform: The transforms for keys diot_frozen: Whether to generate a frozen diot. - True: freeze the object recursively if there are Diot objects in descendants - False: Don'f freeze - `shallow`: Only freeze at depth = 1 diot_missing: How to deal with missing keys when accessing them - An exception class or object to raise - A custom function with first argument the key and second the diot object. - Other values will be used as the default value directly Returns: The converted diot object. \"\"\" from argparse import Namespace ret = cls ( { key : val for key , val in vars ( namespace ) . items () if not key . startswith ( \"__\" ) }, diot_nest = diot_nest , diot_transform = diot_transform , diot_frozen = diot_frozen , diot_missing = diot_missing , ) if not recursive : return ret for key , value in ret . items (): if isinstance ( value , Namespace ): ret [ key ] = cls . from_namespace ( value ) return ret def __init__ ( self , * args , ** kwargs ): if self . __dict__ . get ( \"__inited__\" ): return self . __dict__ [ \"__inited__\" ] = True self . __dict__ . setdefault ( \"__diot__\" , {}) self . __diot__ [ \"keymaps\" ] = {} self . __diot__ [ \"nest\" ] = kwargs . pop ( \"diot_nest\" , True ) self . __diot__ [ \"nest\" ] = ( [ dict , list , tuple ] if self . __diot__ [ \"nest\" ] is True else [] if self . __diot__ [ \"nest\" ] is False else list ( self . __diot__ [ \"nest\" ]) if isinstance ( self . __diot__ [ \"nest\" ], tuple ) else self . __diot__ [ \"nest\" ] if isinstance ( self . __diot__ [ \"nest\" ], list ) else [ self . __diot__ [ \"nest\" ]] ) self . __diot__ [ \"transform\" ] = kwargs . pop ( \"diot_transform\" , \"safe\" ) self . __diot__ [ \"frozen\" ] = False self . __diot__ [ \"missing\" ] = kwargs . pop ( \"diot_missing\" , DIOT_MISSING_DEFAULT ) diot_frozen = kwargs . pop ( \"diot_frozen\" , False ) if isinstance ( self . __diot__ [ \"transform\" ], str ): self . __diot__ [ \"transform\" ] = TRANSFORMS [ self . __diot__ [ \"transform\" ]] super () . __init__ ( * ( arg for arg in args if arg is not None ), ** kwargs , ) for key in self : transformed_key = self . __diot__ [ \"transform\" ]( key ) if transformed_key in self . __diot__ [ \"keymaps\" ]: raise KeyError ( f \"Keys { self . __diot__ [ 'keymaps' ][ transformed_key ] !r} and \" f \" { key !r} will be transformed to the same attribute. \" \"Either change one of them or use a different \" \"diot_transform function.\" ) self . __diot__ [ \"keymaps\" ][ transformed_key ] = key # nest values for key in self : self [ key ] = nest ( self [ key ], self . __diot__ [ \"nest\" ], self . __class__ , self . __diot__ [ \"frozen\" ] is True , ) self . __diot__ [ \"frozen\" ] = diot_frozen def __setattr__ ( self , name : str , value : Any ) -> None : if self . __diot__ [ \"frozen\" ]: raise DiotFrozenError ( \"Cannot set attribute to a frozen diot.\" ) self [ name ] = nest ( value , self . __diot__ [ \"nest\" ], self . __class__ , self . __diot__ [ \"frozen\" ], ) def __setitem__ ( self , name : str , value : Any ) -> None : DOCS if self . __diot__ [ \"frozen\" ]: raise DiotFrozenError ( \"Cannot set item to a frozen diot.\" ) transformed_key = self . __diot__ [ \"transform\" ]( name ) if ( transformed_key in self . __diot__ [ \"keymaps\" ] and transformed_key != name and self . __diot__ [ \"keymaps\" ][ transformed_key ] != name and value is not self [ transformed_key ] ): raise KeyError ( f \" { name !r} will be transformed to the same attribute as \" f \" { self . __diot__ [ 'keymaps' ][ transformed_key ] !r} . \" \"Either use a different name or \" \"a different diot_transform function.\" ) self . __diot__ [ \"keymaps\" ][ transformed_key ] = name super () . __setitem__ ( name , nest ( value , self . __diot__ [ \"nest\" ], self . __class__ , self . __diot__ [ \"frozen\" ] is True , ), ) def __getattr__ ( self , name : str ) -> Any : if name == \"__diot__\" : return self . __dict__ [ \"__diot__\" ] try : return self [ name ] except Exception as exc : # if self.__diot__[\"missing\"] is DIOT_MISSING_DEFAULT: # In case it is picked somewhere else if isinstance ( self . __diot__ [ \"missing\" ], _DiotMissingDefault ): raise AttributeError ( f \" { self . __class__ . __name__ } object has no attribute { name !r} \" ) from None raise exc from None def __getitem__ ( self , name : str ) -> Any : DOCS original_key = self . __diot__ [ \"keymaps\" ] . get ( name , name ) try : return super () . __getitem__ ( original_key ) except KeyError as keyerr : missing_handler = self . __diot__ [ \"missing\" ] # if self.__diot__[\"missing\"] is DIOT_MISSING_DEFAULT: # In case it is picked somewhere else if isinstance ( self . __diot__ [ \"missing\" ], _DiotMissingDefault ): raise if isinstance ( missing_handler , Exception ): raise missing_handler from None if ( isinstance ( missing_handler , type ) and issubclass ( missing_handler , Exception ) ): raise missing_handler ( str ( keyerr )) from None if callable ( missing_handler ): return missing_handler ( name , self ) # type: ignore return missing_handler def pop ( self , name : str , * value ) -> Any : DOCS \"\"\"Pop a key from the object and return the value. If key does not exist, return the given default value Args: name: The key value: The default value to return if the key does not exist Returns: The value corresponding to the name or the default value Raises: DiotFrozenError: when try to pop from a frozen diot \"\"\" if self . __diot__ [ \"frozen\" ]: raise DiotFrozenError ( \"Cannot pop a frozen diot.\" ) if name in self . __diot__ [ \"keymaps\" ]: name = self . __diot__ [ \"keymaps\" ][ name ] del self . __diot__ [ \"keymaps\" ][ name ] if value : return super () . pop ( name , value [ 0 ]) return super () . pop ( name ) def popitem ( self ) -> Tuple [ str , Any ]: DOCS \"\"\"Pop last item from the object Returns: A tuple of key and value Raises: DiotFrozenError: when try to pop from a frozen diot \"\"\" if self . __diot__ [ \"frozen\" ]: raise DiotFrozenError ( \"Cannot popitem of a frozen diot.\" ) key , val = super () . popitem () if key in self . __diot__ [ \"keymaps\" ]: del self . __diot__ [ \"keymaps\" ][ key ] else : del self . __diot__ [ \"keymaps\" ][ self . __diot__ [ \"transform\" ]( key )] return key , val def update ( self , * value , ** kwargs ) -> None : DOCS \"\"\"Update the object. Shortcut: `|=` Args: args: args that can be sent to dict to update the object kwargs: kwargs that can be sent to dict to update the object Raises: DiotFrozenError: when try to update a frozen diot \"\"\" if self . __diot__ [ \"frozen\" ]: raise DiotFrozenError ( \"Cannot update a frozen diot.\" ) dict_to_update = dict ( * value , ** kwargs ) for key , val in dict_to_update . items (): self [ key ] = nest ( val , self . __diot__ [ \"nest\" ], type ( self ), False ) def update_recursively ( self , * value , ** kwargs ) -> None : DOCS \"\"\"Update the object. Shortcut: `|=` Args: args: args that can be sent to dict to update the object kwargs: kwargs that can be sent to dict to update the object Raises: DiotFrozenError: when try to update a frozen diot \"\"\" if self . __diot__ [ \"frozen\" ]: raise DiotFrozenError ( \"Cannot update a frozen diot.\" ) dict_to_update = dict ( * value , ** kwargs ) for key , val in dict_to_update . items (): if ( key not in self or not isinstance ( self [ key ], type ( self )) or not isinstance ( val , dict ) ): self [ key ] = nest ( val , self . __diot__ [ \"nest\" ], type ( self ), False , ) else : self [ key ] . update_recursively ( val ) def __or__ ( self , other : Any ) -> Diot : ret = self . copy () ret . update ( other ) return ret def __ior__ ( self , other : Any ) -> Diot : DOCS self . update ( other ) return self def __delitem__ ( self , name : str ) -> None : DOCS if self . __diot__ [ \"frozen\" ]: raise DiotFrozenError ( \"Cannot delete from a frozen diot.\" ) if name in self . __diot__ [ \"keymaps\" ]: super () . __delitem__ ( self . __diot__ [ \"keymaps\" ][ name ]) del self . __diot__ [ \"keymaps\" ][ name ] else : super () . __delitem__ ( name ) del self . __diot__ [ \"keymaps\" ][ self . __diot__ [ \"transform\" ]( name )] __delattr__ = __delitem__ def _repr ( self , hide = None , items = \"dict\" ): \"\"\"Compose the repr for the object. If the config item is default, hide it. If argument hide is specified, hide that item anyway\"\"\" diot_class = self . __class__ . __name__ diot_transform = self . __diot__ [ \"transform\" ] for key , val in TRANSFORMS . items (): if val is diot_transform : diot_transform = key break diot_transform = ( None if diot_transform == \"safe\" or hide == \"transform\" else diot_transform ) diot_transform = ( \"\" if diot_transform is None else f \", diot_transform= { diot_transform } \" ) diot_nest = \",\" . join ( sorted ( dn . __name__ for dn in self . __diot__ [ \"nest\" ]) ) diot_nest = ( None if diot_nest == \"dict,list,tuple\" or hide == \"next\" else diot_nest ) diot_nest = \"\" if diot_nest is None else f \", diot_nest= { diot_nest } \" diot_frozen = ( None if self . __diot__ [ \"frozen\" ] is False or hide == \"frozen\" else self . __diot__ [ \"frozen\" ] ) diot_frozen = ( \"\" if diot_frozen is None else f \", diot_frozen= { diot_frozen } \" ) diot_items = self if items == \"dict\" else list ( self . items ()) return ( f \" { diot_class } ( { diot_items } \" f \" { diot_transform }{ diot_nest }{ diot_frozen } )\" ) def __repr__ ( self ) -> str : return self . _repr () def __str__ ( self ) -> str : return repr ( dict ( self )) def freeze ( self , frozen : Union [ str , bool ] = \"shallow\" ) -> None : DOCS \"\"\"Freeze the diot object Args: frozen: The frozen argument indicating how to freeze: shallow: only freeze at depth=1 True: freeze recursively if there are diot objects in children False: Disable freezing \"\"\" self . __diot__ [ \"frozen\" ] = frozen if frozen is True : for val in self . values (): if isinstance ( val , Diot ): val . freeze ( True ) def unfreeze ( self , recursive : bool = False ) -> None : DOCS \"\"\"Unfreeze the diot object Args: recursive: Whether unfreeze all diot objects recursively \"\"\" self . __diot__ [ \"frozen\" ] = False if recursive : for val in self . values (): if isinstance ( val , Diot ): val . unfreeze ( True ) @contextmanager DOCS def thaw ( self , recursive : bool = False ): \"\"\"A context manager for temporarily change the diot Args: recursive: Whether unfreeze all diot objects recursively Yields: self, the reference to this diot. \"\"\" self . unfreeze ( recursive ) yield self self . freeze ( recursive or \"shallow\" ) def setdefault ( # type: ignore[override] DOCS self , name : str , value : Any , ) -> Any : \"\"\"Set a default value to a key Args: name: The key name value: The default value Returns: The existing value or the value passed in Raises: DiotFrozenError: when try to set default to a frozen diot \"\"\" if self . __diot__ [ \"frozen\" ]: raise DiotFrozenError ( \"Cannot setdefault to a frozen diot.\" ) if name in self : return self [ name ] self [ name ] = value return self [ name ] def accessible_keys ( self ) -> Iterable [ str ]: DOCS \"\"\"Get the converted keys Returns: The accessible (transformed) keys \"\"\" return self . __diot__ [ \"keymaps\" ] . keys () def get ( self , name : str , value : Any = None ) -> Any : DOCS \"\"\"Get the value of a key name Args: name: The key name value: The value to return if the key does not exist Returns: The corresponding value or the value passed in if the key does not exist \"\"\" name = self . __diot__ [ \"keymaps\" ] . get ( name , name ) return super () . get ( name , nest ( value , self . __diot__ [ \"nest\" ], self . __class__ , self . __diot__ [ \"frozen\" ] is True , ), ) def __contains__ ( self , name : Any ) -> bool : DOCS if name in self . __diot__ [ \"keymaps\" ]: return True return super () . __contains__ ( name ) def clear ( self ) -> None : DOCS \"\"\"Clear the object\"\"\" if self . __diot__ [ \"frozen\" ]: raise DiotFrozenError ( \"Cannot clear a frozen diot.\" ) super () . clear () self . __diot__ [ \"keymaps\" ] . clear () def copy ( self ) -> Diot : DOCS \"\"\"Shallow copy the object Returns: The copied object \"\"\" return self . __class__ ( list ( self . items ()), diot_nest = self . __diot__ [ \"nest\" ], diot_transform = self . __diot__ [ \"transform\" ], diot_frozen = self . __diot__ [ \"frozen\" ], diot_missing = self . __diot__ [ \"missing\" ], ) __copy__ = copy def __deepcopy__ ( self , memo : Optional [ Dict [ int , Any ]] = None ) -> Diot : out = self . __class__ () for dk , dv in self . __diot__ . items (): out . __diot__ [ dk ] = deepcopy ( dv ) memo = memo or {} memo [ id ( self )] = out for key , value in self . items (): out [ key ] = deepcopy ( value , memo ) return out # for pickling and unpickling def __getstate__ ( self ): return {} def __getnewargs_ex__ ( self ): return ( ( list ( self . items ()),), { \"diot_transform\" : self . __diot__ [ \"transform\" ], \"diot_nest\" : self . __diot__ [ \"nest\" ], \"diot_frozen\" : self . __diot__ [ \"frozen\" ], \"diot_missing\" : self . __diot__ [ \"missing\" ], }, ) def to_dict ( self ) -> Dict [ str , Any ]: DOCS \"\"\" Turn the Box and sub Boxes back into a native python dictionary. Returns: The converted python dictionary \"\"\" return to_dict ( self ) dict = as_dict = to_dict def to_json ( DOCS self , filename : Optional [ Union [ str , PathLike ]] = None , encoding : str = \"utf-8\" , errors : str = \"strict\" , ** json_kwargs , ) -> Optional [ str ]: \"\"\"Convert to a json string or save it to json file Args: filename: The filename to save the json to, if not given a json string will be returned encoding: The encoding for saving to file errors: The errors handling for saveing to file See python's open function **json_kwargs: Other kwargs for json.dumps Returns: The json string with filename is not given \"\"\" import json json_dump = json . dumps ( self . to_dict (), ensure_ascii = False , ** json_kwargs ) if not filename : return json_dump with open ( filename , \"w\" , encoding = encoding , errors = errors ) as fjs : fjs . write ( json_dump ) return None json = as_json = to_json def to_yaml ( DOCS self , filename : Optional [ Union [ str , PathLike ]] = None , default_flow_style : bool = False , encoding : str = \"utf-8\" , errors : str = \"strict\" , ** yaml_kwargs , ) -> Optional [ str ]: \"\"\"Convert to a yaml string or save it to yaml file Args: filename: The filename to save the yaml to, if not given a yaml string will be returned default_flow_style: The default flow style for yaml dumping See `yaml.dump` encoding: The encoding for saving to file errors: The errors handling for saveing to file See python's open function **yaml_kwargs: Other kwargs for `yaml.dump` Returns: The yaml string with filename is not given \"\"\" try : import yaml # type: ignore[import] except ImportError : # pragma: no cover raise ImportError ( \"You need pyyaml installed to export Diot as yaml.\" ) from None yaml_dump = self . to_dict () if not filename : return yaml . dump ( yaml_dump , default_flow_style = default_flow_style , ** yaml_kwargs ) with open ( filename , \"w\" , encoding = encoding , errors = errors ) as fyml : yaml . dump ( yaml_dump , stream = fyml , default_flow_style = default_flow_style , ** yaml_kwargs , ) return None yaml = as_yaml = to_yaml def to_toml ( DOCS self , filename : Optional [ Union [ str , PathLike ]] = None , encoding : str = \"utf-8\" , errors : str = \"strict\" , ) -> Optional [ str ]: \"\"\"Convert to a toml string or save it to toml file Args: filename: The filename to save the toml to, if not given a toml string will be returned encoding: The encoding for saving to file errors: The errors handling for saveing to file See python's open function Returns: The toml string with filename is not given \"\"\" try : import rtoml # type: ignore[import] except ImportError : # pragma: no cover raise ImportError ( \"You need rtoml installed to export Diot as toml.\" ) from None toml_dump = self . to_dict () if not filename : return rtoml . dumps ( toml_dump ) with open ( filename , \"w\" , encoding = encoding , errors = errors ) as ftml : rtoml . dump ( toml_dump , ftml ) return None toml = as_toml = to_toml class CamelDiot ( Diot ): DOCS \"\"\"With camel case conversion\"\"\" def __init__ ( self , * args , ** kwargs ): kwargs [ \"diot_transform\" ] = TRANSFORMS [ \"camel_case\" ] super () . __init__ ( * args , ** kwargs ) def __repr__ ( self ) -> str : return self . _repr ( hide = \"transform\" ) class SnakeDiot ( Diot ): DOCS \"\"\"With snake case conversion\"\"\" def __init__ ( self , * args , ** kwargs ): kwargs [ \"diot_transform\" ] = TRANSFORMS [ \"snake_case\" ] super () . __init__ ( * args , ** kwargs ) def __repr__ ( self ) -> str : return self . _repr ( hide = \"transform\" ) class FrozenDiot ( Diot ): DOCS \"\"\"The frozen diot\"\"\" def __init__ ( self , * args , ** kwargs ): kwargs [ \"diot_frozen\" ] = True super () . __init__ ( * args , ** kwargs ) def __repr__ ( self ) -> str : return self . _repr ( hide = \"frozen\" ) class OrderedDiot ( Diot ): DOCS \"\"\"With key order preserved\"\"\" def __init__ ( self , * args , ** kwargs ): self . __dict__ . setdefault ( \"__diot__\" , {}) self . __diot__ [ \"orderedkeys\" ] = [ key [ 0 ] if isinstance ( key , tuple ) else key for arg in args for key in arg ] + [ key for key in kwargs if not key . startswith ( \"diot_\" )] super () . __init__ ( * args , ** kwargs ) def __repr__ ( self ): return self . _repr ( items = \"items\" ) def __setitem__ ( self , name : str , value : Any ) -> None : DOCS super () . __setitem__ ( name , value ) if name not in self . __diot__ [ \"orderedkeys\" ]: self . __diot__ [ \"orderedkeys\" ] . append ( name ) def items ( self ) -> Iterator [ Tuple [ str , Any ]]: # type: ignore[override] DOCS \"\"\"Get the items in the order of the keys Returns: The items (key-value) of the object \"\"\" return (( key , self [ key ]) for key in self . __diot__ [ \"orderedkeys\" ]) def insert ( DOCS self , position : int , name : Union [ str , Tuple [ str , Any ]], value : Any = None , ) -> None : \"\"\"Insert an item to certain position Args: position: The position where the name-value pair to be inserted name: The key name to be inserted It could also be a tuple of key-value pair. In such a case, value is ignored. It could be an ordered dictionary as well value: The value to be inserted Raises: ValueError: when try to pass a value if name is key-value pair or a dictonary. ValueError: when name is a tuple but not with 2 elements \"\"\" if position is None : position = len ( self ) if isinstance ( name , tuple ): # key-value pair if value is not None : raise ValueError ( \"Unnecessary value provided when key-value pair is passed.\" ) if len ( name ) != 2 : raise ValueError ( \"Expecting a key-value pair (tuple with 2 elements).\" ) name , value = name self . __diot__ [ \"orderedkeys\" ] . insert ( position , name ) self [ name ] = value elif isinstance ( name , dict ): if value is not None : raise ValueError ( \"Unnecessary value provided when \" \"a ordered-dictionary passed.\" ) self . __diot__ [ \"orderedkeys\" ][ position : position ] = list ( name . keys ()) for key , val in name . items (): self [ key ] = val else : self . __diot__ [ \"orderedkeys\" ] . insert ( position , name ) self [ name ] = value def insert_before ( DOCS self , existing_key : str , name : str , value : Any = None ) -> None : \"\"\"Insert items before the specified key Args: existing_key: The key where the new elements to be inserted before name: The key name to be inserted value: The value to be inserted Same as name and value arguments for `insert` Raises: KeyError: when existing key does not exist KeyError: when name is an existing key \"\"\" try : position = self . __diot__ [ \"orderedkeys\" ] . index ( existing_key ) except ValueError : raise KeyError ( \"No such key: %s \" % existing_key ) from None if name in self . __diot__ [ \"orderedkeys\" ]: raise KeyError ( \"Key already exists: %s \" % name ) self . insert ( position , name , value ) def insert_after ( DOCS self , existing_key : str , name : str , value : Any = None ) -> None : \"\"\"Insert items after the specified key Args: existing_key: The key where the new elements to be inserted after name: The key name to be inserted value: The value to be inserted Same as name and value arguments for `insert` Raises: KeyError: when existing key does not exist KeyError: when name is an existing key \"\"\" try : position = self . __diot__ [ \"orderedkeys\" ] . index ( existing_key ) except ValueError : raise KeyError ( \"No such key: %s \" % existing_key ) from None if name in self . __diot__ [ \"orderedkeys\" ]: raise KeyError ( \"Key already exists: %s \" % name ) self . insert ( position + 1 , name , value ) def keys ( self ) -> Iterable : # type: ignore[override] DOCS \"\"\"Get the keys in the order they are added Returns: The keys (untransformed) \"\"\" return ( key for key in self . __diot__ [ \"orderedkeys\" ]) def __iter__ ( self ) -> Iterable : # type: ignore[override] DOCS return iter ( self . keys ()) def values ( self ) -> Iterable : # type: ignore[override] DOCS \"\"\"Get the values in the order they are added Returns: The values of the object \"\"\" return ( self [ key ] for key in self . __diot__ [ \"orderedkeys\" ]) def __delitem__ ( self , name : str ) -> None : DOCS super () . __delitem__ ( name ) name = self . __diot__ [ \"keymaps\" ] . get ( name , name ) del self . __diot__ [ \"orderedkeys\" ][ self . __diot__ [ \"orderedkeys\" ] . index ( name ) ] __delattr__ = __delitem__ def pop ( self , name : str , * value ) -> Any : DOCS ret = super () . pop ( name , * value ) name = self . __diot__ [ \"keymaps\" ] . get ( name , name ) if name in self . __diot__ [ \"orderedkeys\" ]: del self . __diot__ [ \"orderedkeys\" ][ self . __diot__ [ \"orderedkeys\" ] . index ( name ) ] return ret def __reversed__ ( self ) -> Iterable : # type: ignore[override] DOCS return reversed ( self . __diot__ [ \"orderedkeys\" ]) def clear ( self ) -> None : DOCS super () . clear () del self . __diot__ [ \"orderedkeys\" ][:] def copy ( self ) -> OrderedDiot : DOCS out = self . __class__ ( super () . copy ()) out . __diot__ [ \"orderedkeys\" ] = self . __diot__ [ \"orderedkeys\" ][:] return out","title":"diot.diot"},{"location":"api/source/diot/","text":"SOURCE CODE diot DOCS \"\"\"Dot notation and access for dictionaries in python\"\"\" from .diot import ( Diot , CamelDiot , SnakeDiot , FrozenDiot , OrderedDiot , DiotFrozenError ) __version__ = \"0.3.2\"","title":"diot"},{"location":"api/source/diot.transforms/","text":"SOURCE CODE diot. transforms DOCS \"\"\"Key transforms for diot @Attribute: TRANSFORMS: Builtin transforms \"\"\" from typing import Dict , Callable import re import keyword import inflection def safe_transform ( item : str ) -> str : DOCS \"\"\"Transform an arbitrary key into a safe key for dot notation Examples: >>> safe_transform(\"a,b\") # a_b >>> safe_transform(\"a_,_b\") # a__b >>> safe_transform(\"in\") # _in Args: item: The item to be transformed Returns: The safely-transformed item \"\"\" # // support bytes transform to keys in bytes? if isinstance ( item , bytes ): item = item . decode ( \"utf-8\" ) item = str ( item ) item = re . sub ( r '[^A-Za-z0-9_]+' , '.' , item ) item = re . sub ( r '_?\\.+|\\.+_?' , '_' , item ) if not item : return '' return ( '_' + item if item [ 0 ] in '0123456789' or item in keyword . kwlist else item ) def camel_case ( item : str ) -> str : DOCS \"\"\"Transform item to camel case format The item will be first safely-transformed. Examples: >>> camel_case('one_two') # oneTwo >>> camel_case('_one') # _one >>> camel_case('o_one') # oOne Args: item: The item to be transformed Returns: The camel_case-transformed item \"\"\" item = safe_transform ( item ) return inflection . camelize ( item , False ) def snake_case ( item : str ) -> str : DOCS \"\"\"Transform item to snake case The item will be first safely-transformed. Examples: >>> snake_case('oneTwo') # one_two >>> snake_case('One') # one >>> snake_case('1One') # _1_one Args: item: The item to be transformed Returns: The snake_case-transformed item \"\"\" item = safe_transform ( item ) return inflection . underscore ( item ) def upper_case ( item : str ) -> str : DOCS \"\"\"Transform item to upper case The item will be first safely-transformed. Examples: >>> upper_case('oneTwo') # ONETWO >>> upper_case('One') # ONE >>> upper_case('1One') # _1ONE Args: item: The item to be transformed Returns: The uppercase-transformed item \"\"\" item = safe_transform ( item ) return item . upper () def lower_case ( item : str ) -> str : DOCS \"\"\"Transform item to lower case The item will be first safely-transformed. Examples: >>> lower_case('ONETWO') # onetwo >>> lower_case('One') # one >>> lower_case('1One') # _1one Args: item: The item to be transformed Returns: The lowercase-transformed item \"\"\" item = safe_transform ( item ) return item . lower () TRANSFORMS : Dict [ str , Callable [[ str ], str ]] = dict ( safe = safe_transform , safe_transform = safe_transform , camel_case = camel_case , camelCase = camel_case , snake_case = snake_case , upper = upper_case , lower = lower_case , upper_case = upper_case , lower_case = lower_case , uppercase = upper_case , lowercase = lower_case , UPPERCASE = upper_case , UPPER_CASE = upper_case , )","title":"diot.transforms"},{"location":"api/source/diot.utils/","text":"SOURCE CODE diot. utils DOCS \"\"\"Utilities for diot\"\"\" from typing import TYPE_CHECKING , Any , Iterable if TYPE_CHECKING : from .diot import Diot class DiotFrozenError ( Exception ): DOCS \"\"\"When try to modify a frozen diot\"\"\" def nest ( DOCS value : Any , types : Iterable [ type ], dest_type : type , frozen : bool , ) -> Any : \"\"\"Convert values with certain types recursively\"\"\" # nothing to convert if not types or not isinstance ( value , tuple ( types )): # type: ignore return value if ( list in types and isinstance ( value , list )) or ( # type: ignore tuple in types and isinstance ( value , tuple ) # type: ignore ): # use value.__class__ to keep user-subclassed list or tuple out = [ nest ( val , types , dest_type , frozen ) for val in value ] try : return value . __class__ ( out ) except Exception : # pragma: no cover return out if dict in types and isinstance ( value , dict ): # type: ignore if issubclass ( value . __class__ , dest_type ): return value return dest_type ( [ ( key , nest ( val , types , dest_type , frozen )) for key , val in value . items () ] ) return value def to_dict ( value : \"Diot\" ) -> dict : DOCS \"\"\"Convert converted Diot objects back to dict\"\"\" if isinstance ( value , dict ): return { key : to_dict ( val ) for key , val in value . items ()} if isinstance ( value , tuple ): return tuple (( to_dict ( val ) for val in value )) if isinstance ( value , list ): return [ to_dict ( val ) for val in value ] return value","title":"diot.utils"}]}